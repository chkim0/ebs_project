<SAMI>
<HEAD>
<TITLE>Time Tools (C) CCNSOFT 2005</TITLE>
<STYLE TYPE="text/css">
<!--
P { margin-left:8pt; margin-right:8pt; margin-bottom:2pt;
    margin-top:2pt; font-size:12pt; text-align:left;
    font-family:굴림, Arial; font-weight:normal; color:white;
    background-color:#405A8D; }
.KRCC { Name:한국어; lang:ko-KR; SAMIType:CC; }
#STDPrn { Name:Standard Print; }
#LargePrn { Name:Large Print; font-size:20pt; }
#SmallPrn { Name:Small Print; font-size:10pt; }
-->
</STYLE>
</HEAD>
<BODY>

<SYNC Start=2454><P Class=KRCC>
풀벌레 소리가 들려요. 아이유 님, 이즈 님이 이 노래 불러주시면 너무 좋을 것 같은데. 이즈 님께 추천드립니다. 예전 노래인데 노래 되게 좋아요. 들어봐. 풀벌레 소리가 어울릴까, 빗소리가 어울릴까 채민아? 

<SYNC Start=27684><P Class=KRCC>
-풀벌레 소리. 

<SYNC Start=31501><P Class=KRCC>
-풀벌레 소리가 어울릴까, 새소리가 어울릴까? 

<SYNC Start=35243><P Class=KRCC>
-풀벌레 소리. 

<SYNC Start=38165><P Class=KRCC>
-풀벌레 소리가 어울릴까, 아니면 숲속 괜찮을까? 
<SYNC Start=45645><P Class=KRCC>&nbsp;



<SYNC Start=55241><P Class=KRCC>
바람이 불어 꽃이 떨어져도 그대 날 위해 울지 말아요. 내가 눈 감고 강물이 되면 그대의 꽃잎도 띄울게. 나의 별들도 가을로 사라져. 그대 날 위해 울지 말아요. 

<SYNC Start=102996><P Class=KRCC>
내가 눈 감고 바람이 되면 그대의 별들도 띄울게. 이 생명 이제 저물어요. 언제까지. 무엇 할 차례예요? 

<SYNC Start=135826><P Class=KRCC>
-7번 풀 차례예요. 

<SYNC Start=136798><P Class=KRCC>
-7번 풀 차례예요? 어려운 문제 다섯 문제 남은 것으로 기억하고요. 그것을 토대로 아주 깔끔한 이야기. 아이스크림 집 이야기로 흘러가는 날이에요. 호텔에 이어서 아이스크림 먹으러 출발을 해보도록 하십시다. 출발. 
<SYNC Start=152774><P Class=KRCC>&nbsp;



<SYNC Start=165842><P Class=KRCC>
좌표평면 위의 점 P가 있어. 잘 들어봐. 이것은 한 번 이동할 때마다 x축의 방향으로 1만큼 평형 이동할 수도 있고 -1만큼, 1 아니면 -1만큼. 무슨 말일까? 어떻게 이동하는 것이야? 

<SYNC Start=174557><P Class=KRCC>
위아래 좌우, 동서남북으로밖에 이동 안 하는 것이지요. 그러니까 좌표 평면상에서 이동한다고 그러면 어떤 점에서 원점에서 출발한다고 그러면 한 번 움직일 때마다 여기로, 여기로, 여기로, 여기로 이것밖에 없어. 

<SYNC Start=186884><P Class=KRCC>
x좌표가 하나 커지든가 하나 작아지든가 y좌표가 하나 커지든가 하나 작아지든가. 이런 액션을 a라고 그러고 이런 액션을 b라고 그러고 이런 액션을 c, 이것을 d라고 그러면 

<SYNC Start=197944><P Class=KRCC>
만약 a라는 액션이 3번, b라는 액션이 1번, c라는 액션이 2번, d라는 액션이 1번 일어났어. 그러면 원점에서 출발한 그 점 P는 어디에 있을까? 한 번 이동할 때마다 이런 액션이 각각 이루어지는 것이니까 

<SYNC Start=211191><P Class=KRCC>
총 합치면 a가 3번 일어났고 b가 1번, c가 2번, d가 1번 일어났으면 전체적으로 7번 움직인 것이지요. 7번 이동 후에 점 P의 위치를 구하라. 이것은 원점에서 출발했다. 

<SYNC Start=222169><P Class=KRCC>
이런 이야기가 나오면 최종적인 답은 a가 3번 일어났는데 a가 일어날 때마다 1번씩 평형 이동하니까 x좌표가 +3만큼. c가 움직일 때마다 x좌표가 하나씩 주니까 x좌표는 -1만큼. 

<SYNC Start=236494><P Class=KRCC>
그러니까 최종적인 x좌표를 구하라고 그러면 2가 되는 것이고요. 그다음에 c가 1번 일어날 때마다 y좌표가 1만큼 커지는데 2번 일어났으니까 2번 움직였을 것 아니야? 

<SYNC Start=245900><P Class=KRCC>
그런데 d가 1번 움직였으니까 또다시 밑으로 1칸 움직일 것 아니에요? 그래서 1이 되는 것이야. 그러니까 총 몇 번 이동 후에? 7번 이동한 후에 (2, 1)로 갈 수 있어. 

<SYNC Start=257988><P Class=KRCC>
그런데 문제는 뭐냐 하면 5번 이동 후에 처음으로 점P가 (2, 1)에 놓이게 되는 경우의 수를 구하라는 이야기야. (2, 1)로는 와야 하는데 5번 이동 후에. 그러면 이렇게 이야기하자고. 

<SYNC Start=275982><P Class=KRCC>
이런 a라는 액션이, a라는 액션이라기보다 (가)라는 액션이 a번 일어났다고 치면 이것을 b번, c번, d번 일어났다고 하면 어떻게 하면 결국 (2, 1)에 다다를 수 있을까? 

<SYNC Start=293223><P Class=KRCC>
그 이야기는 x좌표가 총 2만큼 커져야 하고 y좌표가 총 1만큼 커져야 하지요. 왜? 원점에서 출발해서 (2, 1)로 가라는 이야기는 x좌표는 2만큼 커져야 하고 y좌표는 1만큼 커져야 하는 것이니까 

<SYNC Start=308431><P Class=KRCC>
x좌표가 커지려면 (가)라는 액션이 a번 일어나면 되는 것이거든요. 그러니까 한 번 일어날 때마다 x좌표가 1번씩 커지니까, 이렇게 이야기하지 말고 이런 행동을 a라고 이야기하면. 그냥 (가), (나), (다), (라)라고 이야기해. 

<SYNC Start=337214><P Class=KRCC>
(가)라는 이동 그렇게 이야기하자. (가)라는 이동이 총 a번 발생했다고 그러면 1번 발생할 때마다 x축의 방향이 1만큼 커지니까 a번 발생하면 x좌표가 얼마큼 커지겠어요? a만큼 커질 것 아니야? 

<SYNC Start=352241><P Class=KRCC>
(나)라는 이동이 1번 일어날 때마다 x좌표가 -1만큼 평행 이동하는데 b번 일어났다고 그러면 -1이 b번 움직일 테니까. 이것이 a번 일어나고 이것이 b번 일어나면 최종적인 x좌표를 이야기하라고 그러면 얼마야? 

<SYNC Start=365971><P Class=KRCC>
a-b가 되는 것이야. 그것이 2가 되어야 한다는 것이지. 이해가 돼요? 왜? x좌표가 원점에서 출발해서 (2, 1)로 가라고 했는데 x좌표가 2만큼 커지는 것이니까. 

<SYNC Start=376817><P Class=KRCC>
(가)라는 이 이동이 a번 일어나고 (나)라는 이동이 b번 일어나면 최종적으로 x좌표가 2만큼 커지라는 의미가 무엇이냐? (가)라는 이동이 a번 일어날 때마다 x좌표가 1 커질 것이고 

<SYNC Start=394261><P Class=KRCC>
(나)라는 이동이 b번 일어날 때마다 x좌표는 -1번 커질 테니까 2개를 더한 값이 +2가 되면 최종적인 점 P의 x좌표는 2로 고정되지 않겠느냐? y좌표는 최종적으로 +1이 되어야 하는데요. 

<SYNC Start=411271><P Class=KRCC>
(다)라는 이동이 c번 일어난다고 그러면 c번 일어날 때마다 모두 y좌표로 1씩 커지니까 y좌표의 변화량을 이야기하라고 그러면 c가 될 것이고. (라)라는 이동이 d번 발생한다면 

<SYNC Start=426825><P Class=KRCC>
한 번 움직일 때마다 -1만큼이니까 마찬가지로 이것이 되는 것이고. 이것이 무엇이 돼? 1이 되라는 뜻이라고요. 
<SYNC Start=432411><P Class=KRCC>&nbsp;



<SYNC Start=439655><P Class=KRCC>
그리고 총 이동 횟수는 얼마가 되어야 해? 5번 이동하라고 그랬으니까 a+b+c+d는 무엇이 돼요? 5가 되어야 한다는 이야기지. 그런데 여기에서 나오는 사건이 무엇이라고? 

<SYNC Start=452029><P Class=KRCC>
a-b=2라고 그랬으니까 이 2개가 지금 2 차이 나는 것인데 이것이 이것보다 2 더 큰 것이고. 그다음에 c, d를 봤을 때 c에서 d를 뺀 것이 1이라는 것은 2개가 1 차이 난다는 것이니까 이것보다 이것이 1이 더 크다는 이야기야. 

<SYNC Start=465235><P Class=KRCC>
그러면 총 이것이 (가)라는 이동이 나오는 횟수, 횟수, 횟수, 횟수니까 횟수를 다 더해서 5가 되면서 2개 횟수 차이가 2가 되고, 이것이 이것보다 2가 크고 이것이 이것보다 1이 큰, 

<SYNC Start=476248><P Class=KRCC>
총 다 더해서 5가 되는 경우는 a가 총 얼마고, 이것이 얼마고, 이것이 얼마고, 이것이 얼마여야 하느냐는 것이야. 그러니까 (가)라는 이동이 몇 번 일어나고, 몇 번 일어나고, 몇 번 일어나고, 

<SYNC Start=484642><P Class=KRCC>
몇 번 일어나야 하는지를 체크하시면 되는데 다 더해서 5가 되어야 하거든요. 이렇게 이야기해볼까. 이렇게 이야기해볼까. 어차피 둘 차이는 1이고 둘 차이는 2니까 d를 0이라고 봐. 한 번도 안 일어날 수 있으니까. 

<SYNC Start=495981><P Class=KRCC>
어떤 액션이? (라)라는 이동이 한 번도 안 일어났다는 이야기는 (라)라는 이동이 일어난 횟수를 d라고 그랬으니까 d가 0일 수도 있는 것이지. 그러면 반드시 c는 무엇이 되어야 해? 1. 왜? 2개의 차이가 1 차이 나야 하니까. 

<SYNC Start=508267><P Class=KRCC>
그리고 이것이 0이고 이것이 2면 다 더하면 얼마야? 3밖에 안 되니까 5가 되려면 이것을 무엇으로 갈까? 1. 그러면 이것은 무엇이에요? 3이 될 것 아니에요? 

<SYNC Start=517065><P Class=KRCC>
왜? 2개의 차이가 어차피 2니까. 그런 다음에 4개를 더하면 얼마야? 5가 되니까. 이렇게 5번 이동하면, 다른 말로 (가)라는 이동이 3번, (나)라는 이동이 1번, 

<SYNC Start=528626><P Class=KRCC>
(다)라는 이동을 1번 발생시키면 5번 이동 후에 최종적인 점 P의 위치는 (2, 1)이 될 것이라는 이야기야. 그러면 이렇게 가는 방법밖에 없느냐? 아니. 이것이 1이고 이것이 2일 때도 가능하지요. 

<SYNC Start=547690><P Class=KRCC>
이것이 1이라면 1 차이 나니까 이것은 2. 그러면 이것은 다시 0. 이쪽이 하나 커졌으니까. 그러면 여기는 다시 2. 이것 다 더하면 또 5지요. 그다음에 이것이 0일 때 있고 d가 1일 때 있으니까 

<SYNC Start=560203><P Class=KRCC>
d가 이번에는 2일 때 그러면 이것은 자연스럽게 3이 되는데 벌써 2개 더하면 5가 됐으니까 이쪽에 0 되어야 하는데 이것과 이것의 차이는 2 차이 나니까 아무리 작아봤자 이렇게 나오거든. 

<SYNC Start=570947><P Class=KRCC>
그래서 더 이상 방법이 없다는 것이야. 그러니까 (가), (나), (다), (라)라는 이런 이동이 일어난 횟수를 각각 a, b, c, d라고 했을 때 횟수의 합은 5가 되어야 하고 

<SYNC Start=583966><P Class=KRCC>
이것이 이것보다 2 크고 이것이 이것보다 1 큰 경우는 딱 2가지밖에 없다. 그래서 이런 경우의 수, 이런 경우의 수 구한 다음에 맨 마지막에 더해버리면 답이라는 것이지. 

<SYNC Start=593730><P Class=KRCC>
이해가 돼요? 그런데 이런 경우의 수라는 것은 무슨 말이야? (가)라는 행동이 3번 일어나고 (나)가 1번 일어나고 (다)가 1번 일어난 것이니까 가가가나다 일어나도 (2, 1)로 갈 것이고. 

<SYNC Start=604612><P Class=KRCC>
또는 가나가가다 일어나도 (2, 1)로 갈 것이고. 또는 다가나가가. 지금 무슨 말인지 알겠지? 이런 것이 각각의 경우가 되는 것이니까 최종적인 경우의 수를 구하라는 이야기는 

<SYNC Start=617681><P Class=KRCC>
(가)라는 글자 3개와 (나)라는 글자 하나와 (다)라는 글자 1개를 일렬로 배열하는 방법의 수 5!/3!과 마찬가지. 왜? 3개가 같다. (가)가 3개 같다. 3! 이런 느낌으로. 같은 것이 있는 순열로 해석할 수 있겠구나. 

<SYNC Start=631177><P Class=KRCC>
그래서 20가지가 되는 것이에요. 여기에서 몇 가지가 된다고? 20가지가 된다. 이것은 무슨 말이야? (가)가 2번 일어나고 (다)가 2번 일어나고 (라)가 1번 일어나도 총 5번에 걸쳐서 (2, 1)로 가게 된다는 이야기라고요. 

<SYNC Start=650362><P Class=KRCC>
맞아? 그 이야기는 (가)를 2번 사용해야 하고 또 (다)도 2번 사용해야 하고 (라)를 1번 사용해야 하는 것이니까 총 그런 경우의 수를 구하라는 이야기는 가가다다라를 일렬로 배열하는 방법의 수. 

<SYNC Start=664184><P Class=KRCC>
왜? 이것들의 순서가 달라질 때마다 각각 다른 경우니까. 총 경우의 수를 세라는 것은 (가) 2개, (다) 2개, (라) 하나를 일렬로 배열하는 방법의 수와 똑같다는 것이지요. 

<SYNC Start=673427><P Class=KRCC>
그러니까 5개의 글자라면 5!이고요. 2개가 같으니까 2!, 2개가 같으니까 2!. 120을 4로 나누니까 30가지. 그래서 이것은 20가지고 이것은 30가지니까 5번 이동 후에 (2, 1)에 도착하는 방법의 수는 답이 없네. 

<SYNC Start=689743><P Class=KRCC>
6번, 50 이것이 답이 되는 것이지. 이것 2개 나와야 하니까. 맞잖아요? 5번 이동 후에 (2, 1)로 가는 총 방법의 수를 구하라. 그러면 답은 6번이야. 이 이야기가 없으면. 

<SYNC Start=703765><P Class=KRCC>
처음으로, 이런 말이 없으면 5번 이동한 후에 (2, 1)로 가는 방법 이것이 다라니까. 5번 이동 후에 (2, 1)로 도착하는 것이 이것 3번, 1번, 1번 또는 2번, 1번, 1번밖에 없어요. 

<SYNC Start=720541><P Class=KRCC>
3번, 1번, 1번이 20가지고 2번, 2번, 1번이 30가지니까 총 몇 가지? 50가지. 이것이 최종적인 답이 이렇게 나왔어도 4점짜리야. 여기까지 이해가 돼요? 

<SYNC Start=734251><P Class=KRCC>
그런데 무엇이라고 그랬어요? 미치겠다. 처음으로. 그러면 무엇도 있을까? 
<SYNC Start=742597><P Class=KRCC>&nbsp;



<SYNC Start=748805><P Class=KRCC>
(2, 1)에 도착하는데 처음으로 (2, 1). 처음으로 (2, 1)이 아닌 경우는 (2, 1)에 먼저 도착했다가 갔다 오는 것 이런 것 있잖아. 5번 이동해서 (2, 1)로 가는 총 방법의 수는 50가지인데 이 중에서 무엇을 제외시키면 돼요? 

<SYNC Start=774456><P Class=KRCC>
5번보다 적은 횟수로 (2, 1)로 가. (2, 1)이니까 총 3번 움직여도 (2, 1)로 가잖아. 어떻게? 이것 2번, 이것 1번 움직이면 딱 (2, 1)일 것 아니야? 4번에 걸쳐서 갈 수 있는 방법은 없잖아. 

<SYNC Start=788310><P Class=KRCC>
3번에 걸쳐서 (2, 1)로 가, 일단 이렇게. 그런 다음에 갔다 오면 되지. 5번 걸쳐서 (2, 1)이니까 이 안에는 무엇도 들어 있는 것이야? 3번 만에 (2, 1)로 간 다음에 

<SYNC Start=799816><P Class=KRCC>
다른 데 갔다가 다시 돌아오는 것도 이 안에 들어 있는 것이지. 나 지금 무슨 말 하는지 알아요? 단순하게 (2, 1)이니까 이것 2번, 이것 1번 나오면 (2, 1) 아니야? 그런 다음에 이것 1번, 이것 1번 나오면 되지. 

<SYNC Start=817919><P Class=KRCC>
그러면 x좌표가 커졌다가 다시 돌아오니까 (2, 1). 그것이 이 안에 들어 있잖아. 5번 만에 (2, 1)로 가는 것이니까. 그러면 이 50가지 중에서 무엇을 해야 해요? 빼야 해요. 

<SYNC Start=826623><P Class=KRCC>
무엇을 빼야 해요? 3번 만에 (2, 1)로 가고 and 왔다 갔다. 그래서 이것을 이루는 방법이 이 안에 들어 있을 테니까. 이 안에 들어 있는 그것들을 빼줘야지. 
<SYNC Start=839269><P Class=KRCC>&nbsp;



<SYNC Start=846321><P Class=KRCC>
선생님, 3번 만에 (2, 1)로 가는 방법이 이것밖에 없어. 어떻게? 이것 2번에 이것 1번이잖아. (가) 2번, (다) 1번. 이러면 3번 만에 (2, 1)로 간다고. 그러면 이런 경우의 수는 총 몇 가지가 있어요? 

<SYNC Start=863868><P Class=KRCC>
가가다도 있고 가다가도 있고 다가가도 있으니까 그것을 다른 말로 무엇이라고 그래? 3개를 줄 세우는데 3!/2! 이것. 그런데 여기에서 끝나면 안 된다고. 

<SYNC Start=874424><P Class=KRCC>
왜 안 끝나야 해? 현재까지는 무엇인데? 3번 만에 (2, 1)로 도착한 다음에 이 안에는 5번에 다시 (2, 1)로 돌아왔다는 이야기는 갔다가 다시 와야 하잖아. 갔다가 다시 오는 방법의 수 몇 가지야? 4가지지. 

<SYNC Start=887948><P Class=KRCC>
갔다가 다시 오는 방법 무엇이야? 이것 무슨 말인지 이해 못 하면 어떡하지? (2, 1)로 지금 왔어. 그런데 2번 더해서 총 5번 만에 다시 (2, 1)로 가려면 방법은 4가지 시작. 이것 4가지밖에 더 있니? 
<SYNC Start=906102><P Class=KRCC>&nbsp;



<SYNC Start=913584><P Class=KRCC>
지금 무슨 말인지 알아요? 지금 말인지 알지? 이것은 어떻게 가는 것이야, (2, 1)로? 이것이 이것이고. 이것은 무엇이야? 다가다는 시작. 이것이 저것이고. 다가가는 무엇이야? 여기까지 3번 만에 왔잖아. 

<SYNC Start=936307><P Class=KRCC>
그런데 이미 3번 만에 도착했으니까 처음으로 (2, 1)에 도착한 것이 아니라 3번 만에 (2, 1)을 도착한 다음에 2번 더 가서 또다시 (2, 1)로 되돌아오는 것. 2번 추가해서 (2, 1)로 되돌아오는 경우도 이 안에 들어 있다고. 

<SYNC Start=951102><P Class=KRCC>
왜? 총 5번 후에 (2, 1)로 온 것은 맞으니까. 그런데 그것들은 빼야 해. 왜? 처음으로 (2, 1)로 가라고 그랬으니까 3번 만에 갔다가 다시 되돌아온 것은 빼자는 것이지. 

<SYNC Start=963780><P Class=KRCC>
그러니까 무엇을 빼? 시작. 지금 무슨 말인지 알겠지? 그렇게 해석해도 충분히 답이 나오지. 이것이 몇 가지? 12가지니까 이 중에서 12가지를 뺀다는 것이야. 그래서 답은 38가지 이렇게 풀면 된다는 것이지. 

<SYNC Start=980901><P Class=KRCC>
그런데 이런 그림적인 생각을 하지 않더라도. 나는 지금 아주 시각적으로 풀었잖아요. 이것 (2, 1)로 도착했는데 2번 더 가야 해. 총 4가지구나. 그런데 그렇게 생각하지 않더라도 무엇이라고 이야기하시면 돼? 

<SYNC Start=998637><P Class=KRCC>
(가), (나)가 동시에 일어나거나 (다), (라)가 동시에 일어나면 되는 것이지. 됐지? 그래서 방법의 수는 총 몇 가지다? 가나나가, 다라라다 4가지 이러셔도 되고. 

<SYNC Start=1008774><P Class=KRCC>
아니면 가나, 그러니까 좌우로 왔다 갔다 해도 자기 자신은 돌아오고 위아래로 왔다 갔다 해도 되니까 좌우로 왔다 갔다 할 것인지 위아래로 왔다 갔다 할 것인지 

<SYNC Start=1017982><P Class=KRCC>
둘 중 하나를 정한 다음에 정했으면 그것들 중에서도 작아졌다 커졌다, 커졌다 작아졌다 2가지씩 있다. 이렇게 보셔도 되는 것이고. 이쪽 4가지라는 것은 조금 전처럼 그림으로 해결하셔도 되고 

<SYNC Start=1028782><P Class=KRCC>
아니면 말로 가나나가, 다라라다 총 4가지다. 이렇게 풀어도 되고. 아니면 가나일지 다라일지 먼저 구분한 다음에 각각은 2가지씩 있다. 이렇게 푸셔도 되고. 아무튼 12가지를 제거시켜야지만 최종적인 답이 된다. 

<SYNC Start=1043256><P Class=KRCC>
이런 느낌이라고요. 잘 보세요. 내가 하는 말 잘 들어봐. 지금 레벨 2 어렵지? 이다음 문제 어렵고 그다음 문제 더 어렵고 더 어렵고 계속 어려울 텐데 

<SYNC Start=1050508><P Class=KRCC>
이 어려운 문제가 나오기 때문에 여러분에게 설명하는 것은 아니라고 보셔야 해. 내가 작년에도 EBS 수능특강을 공부할 때 이렇게 이야기했었거든요. 훨씬 어렵거든, 수능 문제보다. 

<SYNC Start=1058699><P Class=KRCC>
그런데 이것을 해놓으면 수능 문제가 쉬워져요. 그러니까 많은 학생들이 착각하는 것이 선생님, 이렇게 어려운 것은 안 나오니까 이것은 안 할래요. 그러면 계속 어려워요. 그러니까 이것과 똑같은 것이지. 

<SYNC Start=1067586><P Class=KRCC>
고1 이차함수를 공부하면 중3 이차함수는? 솔직하게 샤프를 손가락에 끼운다는 것 자체가 치욕스럽잖아. 발가락으로 풀고 싶잖아요. 중학교 이차함수는. 그런 느낌이라는 것이지. 그래서 그 정도는 해두셔야 한다는 것이에요. 

<SYNC Start=1083372><P Class=KRCC>
그러니까 여러분이 만점 받기를 원하잖아요. 만점 받는 느낌 생각해봐. 옛날에 수학에서 만점 받기는 힘들어도 다른 것에서 만점 받아본 적 있잖아, 기술 이런 것. 

<SYNC Start=1092429><P Class=KRCC>
사행정 사이클 기관, 흡입, 압축, 폭발, 배기. 이렇게 풀어본 적 있잖아. 그런 암기 과목에서 만점 받는 기분이 어때? 겨우 만점이네, 이래? 뭐야, 왜 이렇게 쉬워? 이러면서 만점이잖아. 

<SYNC Start=1104869><P Class=KRCC>
그러니까 40분의 시간이 주어지더라도 5분만에 다 풀잖아. 답 3번, 4번, 3번. 그래서 어떤 생각 들어? 만점 받은 다음에는. 제대로 공부했군, 이런 생각이 들어? 

<SYNC Start=1114771><P Class=KRCC>
아니면 그렇게 열심히 안 해도 맞힐 수 있었잖아, 이런 생각이 드니? 두 번째잖아. 그렇게 열심히 안 해도 충분히 나는 됐었을 것이야. 그런 생각이 분명히 들 것이야. 그런 느낌으로. 

<SYNC Start=1133551><P Class=KRCC>
그래서 정말 중요한 것. 그래서 이 문제는 어렵지만 이것을 포기하지 말라고요. 넘어가지 마시라고요. 끝까지 제가 여러분 이해될 때까지 설명 드리도록 할 테니까 무조건. 

<SYNC Start=1142370><P Class=KRCC>
그리고 그 이해되는 과정 안에서 새로운 생각하는 힘을 기를 수 있는 것이니까 그렇게 이야기하시면 될 것 같다는 이야기지요. 됐습니까? 그런 느낌이 바로 레벨 2의 7번 문제였습니다. 

<SYNC Start=1161026><P Class=KRCC>
그다음에 어디로 넘어갈까요? 8번 문제로 넘어가 보자. 세 문자 a, b, c 중에서 중복을 허락해서 4개를 택할 때 나열한다. 중복을 허락해서 4개를 택한다. 

<SYNC Start=1171212><P Class=KRCC>
그러면 이것이 네 자리 문자열이니까 무엇이 있어? 중복 허락하니까 aaaa도 가능하고 aaba도 가능하고 ccab도 가능하고 되게 많아요. 총 방법의 수는? 이 자리에 올 수 있는 경우의 수 중복 허락한다고 그러면 

<SYNC Start=1182518><P Class=KRCC>
무조건 인터뷰하라고 그랬으니까 3가지, 3가지, 3가지, 3가지. 지금 무슨 말인지 알겠지? a, b, c 3가지. 그러니까 답은 총 몇 가지예요? 81가지. 전체 경우의 수에서 81가지야. 

<SYNC Start=1191649><P Class=KRCC>
그런데 무엇이라고 그랬어? a와 b가 반드시 이웃하도록. a, b가 이웃하는 경우가 반드시 존재하래. 되게 말이 어려운 것이야. a, b가 이웃한 것이 이것도 이웃한 것이지요, 이것도 이웃한 것이고, 이것도 이웃한 것이고. 

<SYNC Start=1205528><P Class=KRCC>
그래서 a, b를 집어넣어야 하겠구나, 또는 b, a를 집어넣어야 하겠구나. 그런 다음에 a, b 집어넣은 다음에 나머지는 아무것이나 와도 된다. 그러면 오버 카운팅이 돼요. 

<SYNC Start=1214618><P Class=KRCC>
다시. a, b가 반드시 존재하도록. 이웃하는 것이 존재하려면 일단 a, b를 먼저 채워 넣자고 생각하고 그런 다음에 나머지 2개는 c가 와도 되고 다른 것이 와도 상관이 없잖아. 

<SYNC Start=1225075><P Class=KRCC>
그렇다고 여기 올 수 있는 경우의 수 3가지, 여기에 올 수 있는 경우의 수 3가지 이렇게 풀면 안 된다고. 오버 카운팅이 된다고. 그 오버 카운팅이 된 느낌을 느끼셔야 해요. 

<SYNC Start=1232115><P Class=KRCC>
왜 그래요? 여기 아무것이나 올 수 있다고 그러면 여기 a 오는 경우도 발생하겠지. 그런데 이 경우는 나중에 무엇도 풀 것이야? b, a가 되는 경우도 따로 풀 것이거든. a, b도 이웃이지만 b, a도 이웃이니까. 

<SYNC Start=1243229><P Class=KRCC>
그래서 이것이 조금만 생각해보면 이것 간단한 이야기가 아니겠네? 그런 생각이 자연스럽게 들 것이라고요. 이것이 보통 일이 아니구나. 그러면 이것을 어떻게 풀 것이냐를 생각해봐야 하는데 이 느낌도 나는 괜찮을 것 같아. 

<SYNC Start=1258787><P Class=KRCC>
어떻게 생각하냐 하면 만약에 c가 없으면 다 이웃하지 않니? 2개 빼놓고. 무슨 말인지 알아요? c가 없다고 생각해봐. a와 b로만 채워져 있어. 예를 들어 a가 3개, b가 하나야. 

<SYNC Start=1273283><P Class=KRCC>
그러면 어떻게 배열해도 무조건 a, b를 이웃하지 않겠니? 생각해봐. a 3개와 b 하나를 일렬로 배열하는데 이웃하지 않도록 만들어봐, a, b가. 불가능하지요. 그러니까 c가 없으면 대부분 다 이웃해. 

<SYNC Start=1286344><P Class=KRCC>
그런데 안 되는 경우는? c가 없는 경우 중에. aaaa, bbbb 그것은 안 되지만. 그래서 이런 느낌이야. 그리고 또 c가 몇 개 있는 경우로? 하나 있는 경우. 그러면 오버 카운팅, 중복해서 이야기할 이유가 없잖아. 

<SYNC Start=1299668><P Class=KRCC>
c가 하나도 없을 때, c가 하나 있을 때, c가 2개 있을 때. 최대 2개밖에 불가능하니까. 왜? a, b가 존재하려면 반드시 2칸은 a, b가 차지하고 있어야 하니까. c가 아무리 많은 칸수를 차지하더라도 2칸밖에 없거든요. 

<SYNC Start=1309412><P Class=KRCC>
그러면 몇 가지로 분류하는 것이 제일 좋아요? 3가지로 분류하는 것이 좋아요. 첫 번째, 두 번째, 세 번째 이렇게 c가 하나도 없을 때, c가 1개 있을 때, c가 2개 있을 때 이렇게 분류해서 

<SYNC Start=1322279><P Class=KRCC>
이런 경우의 수, 이런 경우의 수, 이런 경우의 수 각각 꺼내서 맨 마지막에 더하자. c가 하나도 없을 때 조금 전에 풀었어. 여기에도 c가 없어, c가 없어, c가 없어, c가 없어. 

<SYNC Start=1336228><P Class=KRCC>
a, b가 섞여 있으면 되니까 a 3개와 b 하나도 되고, a 2개와 b 2개를 여기 배열해도 되고, a 하나와 b 3개를 배열해도 되지요. 이것을 배열하는 방법의 수 4가지, 이것을 배열하는 방법의 수 6가지, 

<SYNC Start=1346694><P Class=KRCC>
이것을 배열하는 방법의 수 4가지 다 더하면 14가지 이렇게 풀어도 되고. 아니면 나 같으면 이렇게 하겠어. c가 없을 때 a, b가 이웃하려면 일단 c가 없는 경우의 수는 이 자리에 올 수 있는 경우의 수 몇 가지야? 

<SYNC Start=1360621><P Class=KRCC>
호텔. 2가지, 2가지, 2가지, 2가지 아니에요? 여기 a, b 올 수 있고, a, b 올 수 있고, a, b 올 수 있고, a, b 올 수 있다. 그러니까 2⁴가지고 이것은 16가지인데 그중에서 안 되는 것은 aaaa, bbbb 2개만 빼면 되네. 

<SYNC Start=1378708><P Class=KRCC>
aaaa, bbbb 빼니까 14가지 이렇게 처리하시면 됩니다. 지금 이해되세요? c가 없을 때 a, b가 반드시 이웃하는 경우가 존재하려면 a, b가 1번 이웃하라는 것도 아니고 2번 이웃하라는 것도 아니고 

<SYNC Start=1391527><P Class=KRCC>
존재하도록이라고 했으니까 이것이 말이 어려운 것이야. 
<SYNC Start=1394014><P Class=KRCC>&nbsp;



<SYNC Start=1399808><P Class=KRCC>
그것이 말이 어렵다고요. 그것도 또 이렇게 풀어도 되지요. a, b가 1번 이웃하는 경우, 2번 이웃하는 경우. 그러면 너무나 많이, b, a도 이웃할 수 있고. 각각의 앞쪽에서 이웃하거나 뒤쪽에, 중간에. 

<SYNC Start=1411978><P Class=KRCC>
이런 고려할 사항이 너무 많아서 차라리 c로 분류하는 것이 제일 편할 것이다. c가 없으면 14가지. c가 하나 있을 경우도 생각해 봐. c가 하나래. c가 딱 하나야. 그런데 a, b가 이웃해야 해. 

<SYNC Start=1425470><P Class=KRCC>
그러면 어떻게 해야 해요? 마찬가지로 여기도 ab, 여기도 ab, 여기도 ab가 생기면 되지요. c가 하나 있으면 여기도 ab, 여기도 ab, 여기도 ab 이렇게 있으면 돼요. c가 하나 있으면 ab, ab, ab 이렇게 있으면 돼요. 

<SYNC Start=1439280><P Class=KRCC>
그러려면 어떻게 하면 되느냐? 이 안에 a 2개와 b 하나가 발생해도 되고 또는 b 하나, a2개가 발생하면 되겠네. 그래서 결국 잘 들어봐. c가 하나 있는 경우는, 잘 봐. 

<SYNC Start=1454187><P Class=KRCC>
맨 앞이 c인 경우는 여기가 a 2개와 b 하나를 아무렇게나 배열해도 되고 또는 b 2개와 a 하나를 아무렇게나 배열해도 돼요. 맞아요? 그러니까 c가 하나 있는 것도 맨 앞에 있느냐에 따라서 이렇게 되어 있느냐, 

<SYNC Start=1471170><P Class=KRCC>
아니면 여기에 c가 하나 있느냐에 따라서 조금 달라지겠네. 그리고 이것 말고는 세 번째에 c가 오는 경우와 맨 마지막에 c가 오는 경우 이렇게 4가지로 분류해서 풀 수는 있겠습니다만 

<SYNC Start=1489531><P Class=KRCC>
이때와 이때는 입장이 있고 이때와 이때도 입장이 같으니까 이런 경우의 수, 이런 경우의 수, 이런 경우의 수, 이런 경우의 수를 구할 때 이것과 이것은 똑같이 가고 이것과 이것은 똑같이 가는 방법도 있고 

<SYNC Start=1500515><P Class=KRCC>
아니면 그냥 같은 것이 있는 순열로 가도 돼요. 중복을 허용한 것보다는 조금 더 타이트한 것이 같은 것이 있는 순열이니까. c가 하나 나왔다고 그러면 이런 식으로 아예 생각을 안 하고. 

<SYNC Start=1512430><P Class=KRCC>
생각해봐. 방법은 되게 많아. c가 하나와 a 2개와 b 하나. 또는 c 하나와 b 2개와 a 하나 이것밖에 없으니까 이것을 2가지로 분류하는 것이야. 그래서 이것을 일렬로 배열할 때 

<SYNC Start=1523930><P Class=KRCC>
a, b가 반드시 이웃하는 경우가 생기도록 하는 경우의 수와 이것을 일렬로 배열할 때 a, b가 반드시 이웃하도록 생기는 경우의 수를 각각 구한 다음에 더하는 방법도 있지. 방법은 너무나 많지. 
<SYNC Start=1535662><P Class=KRCC>&nbsp;



<SYNC Start=1542853><P Class=KRCC>
이해돼요? 이것 먼저 풀어볼까. c, a, a, b를 여기에 일렬로 배열하는 방법의 수를 계산하시오. 시작. 4!/2!. 안 되는 경우 있나? 있어요. a와 b를 c가 가로막고 있는 경우. 

<SYNC Start=1560094><P Class=KRCC>
이것들을 일렬로 배열하더라도 어떤 경우가 있을까? c가 이렇게 있고 aa가 있고 b가 여기 있는 경우. 또는 c가 여기 가로막고 있고 여기 bb, 여기 a. 또는 여기 c가 있어서 둘을 가로막는 경우. 

<SYNC Start=1579008><P Class=KRCC>
또 c가 여기 있는데 a, b가 반대로 가로막는 경우. 총 4가지가 있네요. 그 4가지를 빼주면 되겠네요. 
<SYNC Start=1586236><P Class=KRCC>&nbsp;



<SYNC Start=1592914><P Class=KRCC>
일반 분류에서 2가지가 있는 것이지요. 이럴 때는 또 2가지가 있는 것이지. 그러니까 결국 잘 봐, 이렇게 가는 것이야. 이것을 일렬로 배열하는 방법의 수 이것, 이것을 일렬로 배열하는 방법의 수도 이것. 

<SYNC Start=1605628><P Class=KRCC>
그런데 이 중 안 되는 것 몇 가지? 2가지. 이 중 안 되는 것 몇 가지? 2가지. 총 4개를 빼면 되지요. 이해가 돼요? 그런데 이 경우의 수 몇 가지야? 12가지. 여기는? 12가지. 합치면 24가지. 그중에서 4개를 빼는 것이야. 

<SYNC Start=1617537><P Class=KRCC>
20가지 끝. 이런 느낌이 가능하다. 다시. 잘 봐. 이것들을 일렬로 배열하는 방법의 수를 구하시오. 그러면 4! 나누기, 2개가 같다. 2!. 이 중에서 안 되는 것이 a와 b가 c에 의해서, c가 칸막이가 되는 경우. 

<SYNC Start=1638103><P Class=KRCC>
c가 둘을 분리시키는 것이지. 그러려면 한쪽에 2개, 한쪽에 하나면 되니까. 지금 무슨 말인지 알아요? 그러니까 몇 가지야? 2가지야. 왜? c가 여기 있어서 a 2개, b 하나. c가 여기 있어서 여기 a 2개 여기 b 하나. 

<SYNC Start=1653172><P Class=KRCC>
그러니까 이 중에서 2가지를 빼줘야 한다는 느낌. 밑의 것도 마찬가지니까 이렇게 처리하시면 된다는 것이야. 그래서 24를 반으로 쪼개니까 12가 되는데 거기에서 2를 빼줬으니까 10가지. 이것도 10가지. 2개 더하니까 20가지. 

<SYNC Start=1668876><P Class=KRCC>
이렇게 해도 되고 아까처럼 이것이 12가지, 이것 12가지. 시작. 24가지인데 그중에서 2개, 2개를 제외한 20가지다. 이렇게 풀어도 어차피 같은 말이니까. 마지막, c가 2개 있는 경우도 생각해보자. 

<SYNC Start=1690017><P Class=KRCC>
선생님, c가 2개 있다는 이야기는 이것이네요, a, b가 이웃하려면. 그러니까 이것들을 일렬로 배열하는 방법의 수는 4!/2!이잖아. 이것들을 일렬로 배열하는 방법의 수 4!/2!. 

<SYNC Start=1701171><P Class=KRCC>
그런데 이 중에서 a, b가 이웃하지 않도록 만드는 방법 무엇이 있을까? 이것은 되게 많은데. 이 경우에는 이렇게 푸는 것이 나을 것 같은데. 안 되는 것 빼는 것보다 이것들을 그냥 이웃시켜. 

<SYNC Start=1714998><P Class=KRCC>
그러면 이 주머니 하나에 c 2개니까 전체 3개를 줄 세우는 방법의 수. 그런데 주머니 안끼리 자리바꿈 안 된다. 그래서 몇 가지야? 3가지다. 아니지. 내가 지금 무엇 하는 것이야? 

<SYNC Start=1730731><P Class=KRCC>
주머니 안에 있는 것끼리 자리 바꾸는 방법의 수 2가지. 다시 할게요. c, c, 그다음에 주머니 하나를 집어넣자는 것이야. 그러면 c 2개와 주머니 하나니까 전체 몇 개? 3! 나누기, 2개가 같잖아. 

<SYNC Start=1743689><P Class=KRCC>
그래서 2!로 나누는데 이것이 바로 주머니 하나와 c 2개를 일렬로 배열하는 방법의 수. 그런데 일 끝나지 않았어. 무엇이 끝나지 않았어? 이것들끼리 자리 바꿀 수 있으니까. 

<SYNC Start=1754595><P Class=KRCC>
이것들끼리 자리 바꿀 수 있는 경우의 수 몇 가지? 2가지다. 이런 뜻이지. 정확하게 이야기하면 2!가지. 그래서 이렇게 약분하면 총 몇 가지가 돼요? 6가지가 된다는 뜻이라고요. 

<SYNC Start=1768551><P Class=KRCC>
맞아요? 어떻게 하는 경우의 수? c가 2개 들어가는 경우의 수니까 이것들이 반드시 이웃해야 한다고 그랬거든. 이것들이 반드시 이웃하라고 그랬어. a와 b가 이웃하는 a, b가 반드시 존재하도록이라고 그랬으니까. 

<SYNC Start=1782472><P Class=KRCC>
c가 2개 있고 이것들이 하나 있다고 생각하면 결국 전체적으로 3개나 마찬가지니까 3!/2!. 여기에서 2!은 무엇이야? c 2개가 자리바꿈하는 경우의 수라고 생각하시면 돼요. 

<SYNC Start=1794031><P Class=KRCC>
맞아요? 그런 다음에 일이 끝나지 않았어. 무엇이 끝나지 않았어? 주머니 안에 있는 a, b가 서로 자리바꿈하는 경우의 수까지 생각해줘야 하지요. 그래서 2!을 최종적으로 곱하면 된다. 

<SYNC Start=1806936><P Class=KRCC>
그래서 약분해서 몇 가지가 생기는 것이에요? 6가지가 생긴다는 느낌으로 갈 수 있어요. 아니면 어떤 느낌도 가능해? c 2개가 있는 경우 중에서. a, b가 이웃하는 경우의 수. 이렇게 하는 방법도 있지. 

<SYNC Start=1819697><P Class=KRCC>
ccab 이것들을 그냥 일렬로 배열하는 방법의 수 얼마야? 4!. 얼마예요? 2!. 그래서 몇 가지가 나와? 12가지가 나와. 그런데 그중에서 무엇 하는 경우의 수를 빼줘도 돼요? 안 되는 경우의 수를 빼줘도 되지요. 

<SYNC Start=1839063><P Class=KRCC>
안 되는 경우의 수를 빼준다고 그러면 안 되는 경우의 수는 어떤 경우가 안 될까요? a, b가 이웃하지 않도록 하는 경우의 수는 어떤 경우가 있을까? c, c가 가운데에 이렇게 있는 것이야. 

<SYNC Start=1853682><P Class=KRCC>
이렇게 돼 있어서 이웃하지 않도록 하는 방법도 있고. a, b는 이렇게 채워봐야 이웃하지 않을 테니까. 또는 어떤 방법도 있어요? 이렇게 있는 것이지. 아니면 어떤 방법도 있냐 하면 이것을 다 생각할 수 있는 것이지. 

<SYNC Start=1869253><P Class=KRCC>
이런 방법도 있구나. 그래서 이런 경우의 수, 총 몇 가지? 2가지. 여기도 몇 가지? 2가지. 여기도 몇 가지? 2가지가 된다는 것이지. 여기도 2가지고, 여기도 2가지고, 여기도 2가지니까 총 6가지. 

<SYNC Start=1881182><P Class=KRCC>
이런 느낌으로도 충분히 처리할 수 있다는 이야기라고요. 됐어요? 왜 6가지야? 여기 12가지 중에서 몇 가지 빼니까? 6가지 빼니까 최종적으로 12가지다. 안 되는 경우의 수를 최종적으로 빼줘야 하고 6가지다. 

<SYNC Start=1900773><P Class=KRCC>
그래서 최종적인 답 이것을 다 더하라고 그러면 답 몇 가지야? 40가지다. 이런 느낌. 그래서 최종적인 답 5번 이런 느낌으로 처리하는 방법도 있다는 이야기라고요. 

<SYNC Start=1911137><P Class=KRCC>
그러니까 방법은 상당히 여러 가지가 있는데 그것을 다 일일이 셀 줄 아셔야 한다. 됐지요? 여기까지. 그래서 a, b가 이웃하는 방법이 최초에 그냥 생각했을 때 a, b를 만들어버리면 오버 카운팅할 가능성이 상당히 높으니까 

<SYNC Start=1932041><P Class=KRCC>
c가 하나도 없을 때, 그다음에 c가 하나일 때, c가 2개일 때 이렇게 분류해서 정리했다. 그리고 각각을 구하는 방법도 제가 이것을 푸는 방법도 2가지로 설명했잖아요. 

<SYNC Start=1940816><P Class=KRCC>
이것을 푸는 방법도 2가지로 설명했고 이것도 2가지로 설명했고요. 각각 모두 다 2가지씩 있는 것이야. 여사건으로 풀어도 되고 아니면 직접 계산하셔도 되고. 

<SYNC Start=1948165><P Class=KRCC>
이런 느낌이 있는 것이니까 여러분도 다 똑같이 각각의 경우의 수를 생각해보는 것이 좋을 것이라는 말씀을 드릴게요. 여기까지의 레벨 2의 마지막 문제였습니다. 

<SYNC Start=1957873><P Class=KRCC>
이제 드디어 레벨 3로 갑니다. 5 이상의 자연수 n에 대하여, 이렇게 나왔어. 중심각의 크기가 같은 n개의 부채꼴, 그러니까 합동인 부채꼴을 만들고 싶은 것이에요. 중심각의 크기가 같은 것이니까. 

<SYNC Start=1970736><P Class=KRCC>
이것을 5 이상의 자연수에 의해서 이것을 n개로 나눈대. 그러니까 n값이 5면 5개로 나누는 것이야, 부채꼴을. 지금 눈에 보이는 것처럼. n이 6일 때는 6개로 나누고 n이 7일 때는 7개로 나누는데 

<SYNC Start=1985780><P Class=KRCC>
그 나눠진 원판에 숫자들을 1부터 n까지 배열하고 싶대. 예를 들어보자. n 값 무엇이 좋아? 아무것이나 이야기해보세요. 6? 6 좋아하는구나. 언제부터 6 좋아했어? 그 이야기는 뭐냐 하면 이것을 6등분하는 것이야. 

<SYNC Start=2008428><P Class=KRCC>
중심각이 다 60도가 되도록. 그런 다음에 여기에 무엇을 기입해? 1부터 n까지, 6까지 자연수를 기입하는 방법의 수를 구하래. 이것 무슨 순열이야? 원순열이야. 돼요? 이렇게 생각해보는 것이지. 

<SYNC Start=2024339><P Class=KRCC>
그런데 짝수를 적은 부채꼴끼리는 서로 이웃하라고 그랬어, 이웃하지 말라고 그랬어? 짝수를 적은 부채꼴끼리 이웃하지 말라고 그랬고 1을 적은 부채꼴과 n을 적은 부채꼴은 서로 이웃하지 않는다고 그랬어요. 

<SYNC Start=2035251><P Class=KRCC>
그러니까 그냥 1부터 6까지를 그냥 배열하라고 그러면 답은 무엇이야? 5!로 끝날 텐데 짝수는 이웃하지 마라. 1부터 6까지 중에서 홀짝 문제네요. 홀수는 무엇이 있어요? 이 중에서 이것들끼리 이웃하지 마라. 

<SYNC Start=2050206><P Class=KRCC>
그러면 이것들이 무슨 역할 한다? 이것들이 칸막이 역할을 하는 것이지. 원순열, 6명이 원탁에 앉는다. 이것들이 칸막이 역할을 하는 것이지. 그런데 조건 하나가 더 있어. 

<SYNC Start=2063056><P Class=KRCC>
무엇이야? 1과 n, 다른 말로 1과 6은 이웃하지 않도록. 이것과 이것이 이웃하지 않도록, 이런 조건까지 들어 있는 것이야. 그러면 세워보자. 칸막이 먼저 줄 세우면 되잖아. 

<SYNC Start=2073408><P Class=KRCC>
3명을 먼저 앉혀. 2! and. 3명을 먼저 한지 앉혔어. 3명 앉았어. 누구? 1, 3, 5 먼저 앉았어. 그렇게 앉는 방법의 수 2!가지. 그러면 짝수는 어디 앉아야 해요? 이웃하지 않으려면. 여기 3개에 짝수가 앉으면 돼요. 

<SYNC Start=2094160><P Class=KRCC>
그러니까 만약 조건이 (가)라는 조건밖에 없다면 그냥 3!로 마무리 지으면 된다고. 그런데 무슨 조건까지 있어? 1과 6은 서로 이웃하면 안 된대. 6은 무조건 여기 와야 하잖아. 

<SYNC Start=2111091><P Class=KRCC>
무슨 말인지 알아? 6은 무조건 여기 와야 해. 그러니까 6이 올 수 있는 경우의 수 몇 가지? 1가지야. 6야 무조건 여기 와야 하니까. 그다음에 2, 4는 아무렇게나 앉으면 된다. 그래서 최종적인 답 4가지가 나오는 것이에요. 
<SYNC Start=2121821><P Class=KRCC>&nbsp;



<SYNC Start=2128677><P Class=KRCC>
왜? 6은 1과 이웃하지 말라고 그랬으니까. 1과 이웃하는 자리가 2개잖아요. 그러면 6이 올 수 있는 경우의 수 1가지. 이해가 돼요? 
<SYNC Start=2139803><P Class=KRCC>&nbsp;



<SYNC Start=2148766><P Class=KRCC>
그다음에 누구만 앉히면 돼요? 2와 4만 먼저 앉히면 되는 것이지. 2와 4가 앉는 방법은 나머지 두 자리에 아무렇게나 줄 세우면 되니까 이미 다 직순열 모드로 바뀌었으니까 맨 마지막에 2!로 마무리 지으면 된다는 이야기. 

<SYNC Start=2162551><P Class=KRCC>
됐어? 이것이 바로 n이 6일 때야. n이 5일 때도 해볼까요. 이것은 더 쉬울 것 같은데. 쉽나 볼까. 이번에는 이것이잖아. 1부터 5까지 중에서. 짝수는 이웃하지 않도록. 그리고 1과 n은 이것들이 또 이웃하지 않도록 해라. 

<SYNC Start=2190219><P Class=KRCC>
이것도 해볼까요. 어떻게 하면 돼요? 칸막이 먼저 세워요. 3명 먼저 줄 세우세요. 1, 3, 5. 그중에서 하나를 확정 짓자. 이렇게 섰다고 생각해봐. 현재까지 경우의 수 2!가지 and. 왜 2!가지입니까? (n-1)!이니까. 

<SYNC Start=2205564><P Class=KRCC>
그다음에 남아 있는 곳은 여기 세 자리가 남아 있다고. 거기에 누구를 세워야 해? 2, 4를 세워야 해. 그런데 누구와 누구와? 1과 5가 붙으면 안 된다며. 그러니까 여기 오면 되지. 1과 5는 붙으면 안 된다고 그랬잖아요. 

<SYNC Start=2221707><P Class=KRCC>
그러면 여기 안 오면 어떻게 돼요? 2, 4 숫자는 2개밖에 없는데 2, 4가 만약 여기와 여기만 왔다. 그러면 무엇을 해야 해? 붙을 것 아니야? 그런데 붙지 말라고 그랬으니까. 붙지 말라고 그랬구나. 

<SYNC Start=2234396><P Class=KRCC>
붙지 말라고 했으니까 여기는 무조건 앉혀야지. 여기는 무조건 앉혀야 하니까 2, 4라는 짝수 2개 중에서 이 자리에 오는 경우의 수 2가지 and 이렇게 가면 돼요, 하나는 확정 지어 놓고. 

<SYNC Start=2248845><P Class=KRCC>
나머지 4라는 것은 여기 또는 여기 앉으면 되지요. 몇 가지야? 2가지. 그래서 총 몇 가지야? 8가지다. 그 8가지를 이렇게 배열한 것이라고요. 어렵네요. 그래서 짝수일 때와 홀수일 때와 느낌이 조금 다르지요. 

<SYNC Start=2261719><P Class=KRCC>
그런 느낌이 조금 든다는 이야기라고요. 재미있는데? 이렇게 느껴보는 것이야. 이렇게 느껴보는 문제가 예를 들어 문제라고 있어요. 무슨 문제? 예를 들어 문제. 이것이 예전에 30번, 21번이라고 킬러 문제에 많이 나왔다고요. 

<SYNC Start=2281840><P Class=KRCC>
예를 들어, 직접 해보라는 이야기야. n이 올 때 직접 해보면 너 느낌 올 것이야. n이 6일 때도 직접 해보고 n이 7일 때도, n이 8일 때도 직접 해보면 느낌이 올 것이야. 

<SYNC Start=2293057><P Class=KRCC>
그런데 이 문제를 일반화시키래요. n이 짝수일 때와 홀수일 때와 푸는 방법이 조금 다른데 이것과 이것을 나눠서 1/60이 되도록 하는 자연수 n 값을 구하래요. 일반화시키는 문제야. 

<SYNC Start=2307182><P Class=KRCC>
그런데 조금 전에 해봤잖아. n이 5일 때도 해봤고 n이 6일 때도 해봤지만 짝수일 때와 홀수일 때가 분위기가 다르니까 나는 이렇게 이야기하겠어. 어떻게 이야기하냐 하면, 잘 들어봐. n이 짝수일 때부터 시작해보자는 것이지. 

<SYNC Start=2321834><P Class=KRCC>
첫 번째, n이 짝수일 때. n이 짝수일 때 생각해보자는 것이지. 그러면 k는 무엇보다 크거나 같겠니? n은 5보다 크거나 같으니까 k는 3보다 크거나 같다, 이렇게 이야기할 수 있겠지. 

<SYNC Start=2340708><P Class=KRCC>
n이 짝수일 때 k는 3보다 크거나 같다. 그때 홀수와 짝수 중에서 짝수는 이웃하면 안 되고 1과 n은 또 이웃하면 안 되잖아. 그러면 1부터 2k까지. 1부터 2k까지라고 그러면 잘 봐. 

<SYNC Start=2365941><P Class=KRCC>
1, 2, 3, 4, 5, 쭉쭉 나아서 여기가 2k, 여기는 2k-1 이렇게 될 것이라고. 맞아요? 여기 쭉 나가서. 그러면 전체가 2k면 여기부터 여기까지 몇 개가 있어? k개가 있고. 

<SYNC Start=2386300><P Class=KRCC>
여기부터 여기까지 몇 개가 있는 것이야? k가 있는데, 집중해봐. 이것은 무엇 하래요? 칸막이를 하래. 왜? 무엇끼리 이웃하지 말라고 그랬으니까? 짝수끼리 이웃하지 말라고 그랬으니까. 

<SYNC Start=2397977><P Class=KRCC>
그리고 1과 n, 다른 말로 1과 2k는 이웃하면 안 된다. 이렇게 돼 있다고. 여기까지 됐어? 복잡해. 그러면 일단 칸막이를 먼저 세워야 하니까 홀수 몇 개를? k개를 먼저 배열을 하겠다. 

<SYNC Start=2416461><P Class=KRCC>
그것을 무엇이라고 그래? (k-1)!. 왜? 원순열이니까 k개의 홀수들을 먼저 배열했다는 이야기야. 현재까지 모습이야. 1이 어딘가에는 있을 것이고. 이렇게 k개의 홀수들을 완벽하게 배열했다는 이야기라고. 

<SYNC Start=2432293><P Class=KRCC>
현재까지 경우의 수 (k-1)!. 그러면 하나만 묻자. 이것들이 k개라면 칸막이 사이사이도 몇 개야? k개야. 그 k개에 짝수 k개를 집어넣으면 돼. 그런데 그 짝수 중에서 맨 마지막 짝수인 2k는 1과 이웃하면 안 되니까 

<SYNC Start=2449429><P Class=KRCC>
여기와 여기 두 군데로 오면 안 돼. 따라서 2k라는 것이 올 수 있는 경우의 수는 몇 가지일까? 총 k개의 자리 중에 2개 안 되니까 (k-2)가지. 누가 오는 경우의 수? 2k가 오는 경우의 수는 (k-2)가지라는 것이지. 

<SYNC Start=2466295><P Class=KRCC>
그러면 이제 몇 개만 더 앉으면 돼요? (k-1) 되면 어차피 직순열로 바뀌었으니까 (k-1)개면 아무렇게나 앉으면 되잖아. 이것이야. 끝. 아까 n이 6일 때, 다른 말로 k가 3일 때 해볼까요. 

<SYNC Start=2479749><P Class=KRCC>
2×1×2. 아까 4가지 나왔었나? 그렇게 푸는 것이구나. 일반화시켰구나. 따라서 f(n)의 값은, 다른 말로 f(2k)일 때니까 2k의 값은 다음과 같이 된다는 사실을 알 수 있다. (k-1)!(k-2)(k-1)!. 

<SYNC Start=2506761><P Class=KRCC>
선생님, 토 나오려고 그래요. 저도 그래요. 조금 이따가 쉬는 시간에 화장실 갔다 올 것이에요. 되게 어렵잖아요. 맞아, 여러분이 어려움을 느끼는 것만큼 저도 어려움을 느낍니다. 모든 수학 선생님도 똑같이 어려움을 느낍니다. 

<SYNC Start=2521051><P Class=KRCC>
그런데 우리는 해내지요. 여러분은 포기하는 것이고. 그 차이밖에 없어. 그런데 이것은 어렵다기보다 그냥 짜증 나는 것 아니니? 가만히 생각하면 되잖아. 

<SYNC Start=2531729><P Class=KRCC>
짝수끼리 이웃하지 말라고 그랬으니까 홀수를 먼저 배열하려면 1부터 2k까지 중에서 k개가 있네. 일단 홀수를 먼저 배열해야 하니까 일단 k개를 일단 원형의 형태로 배열하면 (k-1)!. 그러면 빈자리 k개 있네. 

<SYNC Start=2545894><P Class=KRCC>
빈자리에 이것만 그냥 채워 넣으면 행복할까? 그런데 2k와 1과 마주치면 안 되네. 1 옆에 바로 두 자리 있는데 거기는 올 수 없네. 그러면 k개의 빈자리 중에서 2자리를 제외한 (k-2)자리에 와야 하네. 누가? 2k. 

<SYNC Start=2558223><P Class=KRCC>
그래서 이것은 2k가 올 수 있는 경우의 수 (k-2)가지. 그러면 2k 왔으니까 2k를 제외한 전체 k개 중에서 (k-1)개는 지금 빈자리 (k-1)개 있으니까 빈자리 (k-1)개를 아무렇게나 줄 세우면 되겠네. 이렇게 되는 것이야. 

<SYNC Start=2569531><P Class=KRCC>
이것이 아주 절대적으로 어려운 이야기는 아닌 것이지. 조금 짜증 날 뿐이고 일반화시켰다는 것이 눈으로 보이는 개수가 아니라 추상적인 개수를, 지금 k개가 있다고 추상적으로 생각하니까 조금 어려울 뿐이지 

<SYNC Start=2579818><P Class=KRCC>
여러분 충분히 해낼 수 있다고 생각해요. 그래서 f(n) 값을 구하는데 여기가 짝수일 때는 해결했어요. 이제 두 번째, 여기가 무엇일 때 해볼까? 홀수일 때 (2k+1)일 때 보자고. (2k+1)로 만들면 여기 하나만 더 있는 것이야. 

<SYNC Start=2595727><P Class=KRCC>
마찬가지로 여기 몇 개? k개. 여기 k개. 거기에 1개를 더 추가. 그런데 마찬가지로 이것은 무슨 역할? 짝수끼리 이웃하면 안 되니까 칸막이 역할. 그리고 1과 n은, n이 바로 2k+1이니까 이것들을 이웃할 수 없다. 

<SYNC Start=2625108><P Class=KRCC>
됐어? 우리는 지금부터 칸막이 먼저 세우겠습니다. 1부터 2k+1까지 몇 개? k개에 1개 추가. k+1개의 칸막이를 원형 형태로 배열하겠습니다. 끝나지 않았어. 그런데 이 안에는 반드시 1이 들어 있을 것이라고. 
<SYNC Start=2644917><P Class=KRCC>&nbsp;



<SYNC Start=2651035><P Class=KRCC>
맞지? 이 안에는 반드시 무엇이 들어있다고? 1이 들어있을 것이라고. 왜? 이것들을 일렬로 배열을 했으니까. 
<SYNC Start=2662594><P Class=KRCC>&nbsp;



<SYNC Start=2673590><P Class=KRCC>
그런데 무엇까지 고려해야 해? 2k+1도 이 안에 들어 있잖아. 그것과 이것은 서로 이웃하면 돼, 안 돼요? 그러면 맨 마지막에 이웃하는 경우의 수를 빼주면 되겠다. 

<SYNC Start=2687506><P Class=KRCC>
이것은 강제적으로 이웃하지 않도록 만들려면 만약 1이 여기 있고 여기가 2k+1이고 여기가 2k+1일 때는 짝수가 여기 안 왔다는 조건하에 붙을 수 있는 것이니까. 

<SYNC Start=2697582><P Class=KRCC>
그런데 만약 2k+1이 여기와 여기 1 주위에 안 오고 이쪽에 있으면 무조건 짝수와 상관없이 2k+1은 이것과 이웃하지 않는 것이니까 이것을 이웃하지 않도록 강제적으로 만들지 말고 나는 이렇게 풀 것 같아. 

<SYNC Start=2710250><P Class=KRCC>
그냥 2k+1까지의 총 k+1개의 칸막이를 먼저 만들어놓고 그리고 짝수를 이웃하지 않도록 만들어놓은 다음에 줄 세운 다음에 맨 마지막에 1과 2k+1이라는 홀수 2개가 이웃하는 경우의 수를 빼주자고. 

<SYNC Start=2724203><P Class=KRCC>
그것이 조금 나을 것 같아. 여사건으로 처리하자는 것이지. 그러니까 이 2가지 조건 중에서 이것은 이웃하지 않도록과 이 2개는 이웃하지 않도록 중에서 이것은 아직 고려하지 말고 

<SYNC Start=2734010><P Class=KRCC>
그냥 짝수를 이웃하지 않도록 만들려면 빈자리 몇 개 있어요? 총 k+1개의 칸막이를 만들었으니까 이 원형 배열에서는 빈자리도 k+1개가 있거든요. 이런 k+1개의 빈자리 중에서 짝수를 몇 개를 앉히면 돼요? 

<SYNC Start=2753148><P Class=KRCC>
k개를 앉히면 되잖아요. 이미 직순열이야. k+1개의 자리 중에서 k개를 뽑아서 줄 세우면 된다고. 이것이 바로 짝수를 이웃하지 않도록 배열하는 방법의 수라고. 이것이 k+1개의 빈자리. 

<SYNC Start=2765929><P Class=KRCC>
빈자리라는 것은 무엇이야? 사이사이. 칸막이가 k+1개였으니까 사이사이도 k+1개가 나오는데 그중에서 짝수는 몇 개밖에 없으니까? k개밖에 없으니까 그중에서 k개를 뽑아서 줄 세우는 것이에요. 

<SYNC Start=2777233><P Class=KRCC>
그런 다음에 아직 일이 끝나지 않았어. 아니, 일은 끝났어. 그런데 빼줘야 돼. 무엇을 빼줘야 돼? 이웃하도록 하는 경우의 수를 빼줘야 하지요. 지금 무슨 말인지 알아? 이웃하도록 하는 경우의 수를 빼줘야 한다고. 

<SYNC Start=2793601><P Class=KRCC>
그러면 이웃하도록 하는 경우의 수는 어떻게 만드느냐? 1과 2k+1이 이웃한다고 그랬으니까 2개를 일단 주머니 속에 집어넣어. 그러면 전체는 k+1개였는데 몇 개나 마찬가지예요? k개나 마찬가지라고. 

<SYNC Start=2807044><P Class=KRCC>
지금 무슨 말인지 이해가 돼요? k개의 칸막이를 먼저 줄 세운다니까. (k-1)!. 그러면 현재까지 모습을 이야기하라고 그러면 이 2개는 주머니 속에 집어넣은 것이니까 

<SYNC Start=2825164><P Class=KRCC>
하나는 1과 2k+1이 들어있고 나머지 것들이 총 몇 개가 있을까? k-1개가 이렇게 있을 것이라고. 그러니까 총 k개의 칸막이를 집어넣은 것이지. 원래는 칸막이가 k+1개인데 2개를 주머니 안에 집어넣었으니까 칸막이가 k개. 

<SYNC Start=2839406><P Class=KRCC>
따라서 원형 배열에서는 빈자리가 몇 개? k개가 있을 것이다, 이런 의미야. 그런데 k개의 빈자리 중에서 짝수도 k개 있으니까 그 빈자리 사이사이 k개의 자리에 k개의 짝수를 배열시키니까 k!인데 아직 일 안 끝났고. 

<SYNC Start=2858316><P Class=KRCC>
왜? 이 주머니 안에 있는 것들끼리 자리 바꿀 수 있잖아. 여기까지다. 돼요? 이것이 어렵구나. 홀수일 때가 어렵네요. 나 지금 어떻게 풀었는지 알겠지? 이것 무엇 한 것이야? 그냥 이것만 고려한 것이야. 짝수가 이웃하지 않도록. 

<SYNC Start=2876518><P Class=KRCC>
그러면 k+1개의 홀수들을 원형 형태로 배열한 다음에 칸막이가 k+1개면 원형 형태는 빈자리도 똑같이 k+1개거든요. 그 k+1개의 빈자리 중에서 짝수 k개를 일렬로 배열하면 되니까. 

<SYNC Start=2893792><P Class=KRCC>
그런데 그중에서 이웃하는 경우를 당연히 젖혀야 하니까 무엇을? 1과 2k+1을 먼저 주머니 속에 집어넣으면 칸막이는 원래는 k+1개지만 그것이 k개로 줄 것이다. 

<SYNC Start=2902440><P Class=KRCC>
그래서 주머니를 포함해서 k개의 칸막이를 일단 배열해놓고. 됐지? 그러면 k개의 칸막이니까 빈자리도 k개 있을 것이라고. 그 k개의 빈자리에 짝수 k개를 일렬로 배열한다고. 

<SYNC Start=2916210><P Class=KRCC>
아직도 일 끝나지 않았어. 왜? 주머니 안끼리 자리 바꿀 수 있어. 됐다. 
<SYNC Start=2920209><P Class=KRCC>&nbsp;



<SYNC Start=2924823><P Class=KRCC>
예쁘게 정리합시다. 이것은 k!이고 이것은 그냥 (k+1)!지요. 왜? 2까지 곱하는 것이잖아. k+1부터 시작해서 하나 주니까. 그런데 1까지 곱해도 상관없으니까 그냥 (k+1)!로 가시고요. 

<SYNC Start=2936688><P Class=KRCC>
이것은 (k-1)!k!×2 이렇게 처리할 수 있어. 무엇으로 끌어낼까? 이것으로 끌어내면 되겠네. 작은 것 기준으로 (k-1)!k!로 끌어내면 여기는 (k+1)과 k가 더 있으니까 k(k+1)이 더 있네요, 이쪽은. (k-1)!까지는 끌어냈으니까. 

<SYNC Start=2958008><P Class=KRCC>
그다음에 이 2개로 끌어냈으니까 여기는 -2로 가시면 되고요. 그러면 k²+k-2네요. k²+k-2니까 (k+2)(k-1) 이렇게 쓰면 되겠네. 그래서 (k+2)(k-1). 

<SYNC Start=2982324><P Class=KRCC>
조금 더 간단하게 고치려고 그랬는데 불가능할 것 같아. 이렇게 만들면 될 것 같아. 좋아요. 참 힘들다. 여기에 (k-1)!k!(k+2)(k-1) 이렇게 처리하시면 됩니다. 
<SYNC Start=3002216><P Class=KRCC>&nbsp;



<SYNC Start=3013653><P Class=KRCC>
n은 5보다 크거나 같다고 했으니까 위에 있는 k는 3보다 크거나 같은 것이고 이것이 5보다 크거나 같다는 이야기는 밑의 것 k는 2보다 크거나 같은 것이에요. 

<SYNC Start=3020632><P Class=KRCC>
여기에서 k는 2보다 크거나 같으니까 3보다 크거나 같다고 해야 한다는 조건은 분명히 들어있다는 것이야. 그런데 최종적인 결론은 뭐냐 하면 다음의 n 값을 구하래. 지금 이것이잖아. 이것을 만족시키는 n 값을 구해야 해. 

<SYNC Start=3035056><P Class=KRCC>
그런데 이것이 짝수면 이것은 홀수고 이것이 홀수면 이것이 짝수. 그러니까 n이 홀수일 때와 n이 짝수일 때와 또 분리시키자고. 그래서 첫 번째 또 간다. n이 짝수일 때와 두 번째, n이 홀수일 때로 분리시키자고. 

<SYNC Start=3051238><P Class=KRCC>
그러면 n이 짝수일 때부터 보면 여기가 2k라고 처리하시면 되니까 f(2k). n 대신 그냥 2k를 집어넣으시면 되잖아요. 여기에 2k를 집어넣으면 f(2k+1) 이렇게 되고 1/60 이렇게 나온다고. 

<SYNC Start=3063983><P Class=KRCC>
그런데 지금 이것은 구해놨잖아. 이것도 여기 구해놨잖아. 여기에서 k 값 구해주시면 되고 그 k 값을 여기에 다시 대입하면 드디어 우리가 원하는 n 값이 나온다는 뜻이에요. 맞아요? 
<SYNC Start=3073196><P Class=KRCC>&nbsp;



<SYNC Start=3079381><P Class=KRCC>
그러면 차근차근 풀자. 이것은 1/60 이렇게 돼 있고요. 첫 번째, f(2k)를 구하라고 그러면 여기에 이것을 그대로 써주면 되니까 (k-1)!(k-2)(k-1)! 이렇게 되고. 분모는 (k-1)!k!(k+2)(k-1) 이렇게 나와요. 

<SYNC Start=3105084><P Class=KRCC>
그래서 (k-1)!, (k-1)! 없어지는 것 또 무엇이 있어? 여기 (k-1)!, k! 이니까 이렇게 하면 분모에 k만 더 남지. 따라서 이렇게 곱한 3차 방정식이네요. k³+k²-2k, 이렇게 곱하면 얼마야? 60k-120 이렇게 나온다고. 

<SYNC Start=3130225><P Class=KRCC>
그래서 이쪽으로 넘기면 k³+k²-62k+120=0. 이것은 무조건 인수분해가 되어야 해. k 값이 정수가 나와야 하니까. 있습니까? 6입니까? 상당히 비현실적이군요. 

<SYNC Start=3154190><P Class=KRCC>
6을 대입하면 216+36-372+120 이것 0 나와? 이렇게 하면 얼마야? 252. 더하면 얼마야? 372. 빼니까 0 나와. 그래서 이것은 (k-6)에 대해서. 거기도 이렇게 풀었어요? 뒤에는 당연히 안 나오겠지. 

<SYNC Start=3191678><P Class=KRCC>
얼마니? +7k야? 그러면 이것이 정수로 인수분해 안 되니까 k는 정수라는 식에서 위배. 됐어요? 그러면 k는 얼마야? 6. 아까 k 조건에도 만족시키니까. k가 6이구나. k가 6이니까 n 값을 구하라고 그러면 답은 12 끝. 

<SYNC Start=3211263><P Class=KRCC>
이렇게 나가는 것이에요. 지금 하나 푼 것이야. n이 짝수일 때. 답은 12. 왜? 모순된 것이 없었으니까 답으로 채택이 되겠지. 그러면 결국 이 n 값이 무엇일 때는 안 된다는 이야기예요? 

<SYNC Start=3223706><P Class=KRCC>
홀수일 때는 안 된다는 이야기일 것 아니에요? 그것도 해보자고요. 홀수일 때는 안 된다는 이야기네요. n이 2k+1일 때, 홀수일 때 안 된다는 이야기네. 그러면 그대로 만들면 되잖아. 

<SYNC Start=3241469><P Class=KRCC>
f(n)을 만들려면 n 대신 2k+1을 집어넣으면 되니까 f(2k+1). 밑은 하나 큰 것이니까 무엇이야? f(2k+2)가 되겠지. 이것이 1/60. 이것은 어떻게 구해? 여기에 k 대신 k+1 대입하면 되지요. 

<SYNC Start=3257246><P Class=KRCC>
k 대신 k+1 대입하니까 이 분모는 무엇이 되냐 하면, 잘 보세요. 여기에 k 대신 k+1을 대입하니까 k!(k-1)k! 이렇게 되고요. 분자는 2k+1 이것을 그대로 써주면 되니까 (k-1)!k!(k+2)(k-1) 이렇게 된다고. 

<SYNC Start=3282446><P Class=KRCC>
(k-1), (k-1) 사라지네. k!, k! 사라지네. 이것도 사라져서 이것은 k만 남네요. 그러면 분모는 k만 생기고. 분자는 무엇만 생겨요? k+2만 생겨요. 그런데 이것이 무엇이 되어야 해? 1/60. 그러면 이렇게 곱하면 60k+120=k. 

<SYNC Start=3301784><P Class=KRCC>
넘어가면 5k=-120이 되어야 하니까 이것을 만족시키는. 5k가 아니라 59k. 59k=-120. 이것을 만족시키는 정수 k는 없으니까 결국 불가능하게 되는 것이고. 

<SYNC Start=3318471><P Class=KRCC>
아까 n이 짝수일 때만 가능하다. 그래서 최종적인 답을 계산하라고 그러면 12가 된다. k가 얼마일 때니까? 6일 때니까. 이런 느낌으로 처리하시면 돼요. 

<SYNC Start=3329096><P Class=KRCC>
실력 완성 레벨 3의 1번까지 풀어봤는데 조금 어렵긴 해요. 그런데 이런 문제의 핵심을 나는 여기에서 이야기하고 싶어. 예를 들어라는 말이 나오면 익숙해져야 해요. 

<SYNC Start=3338334><P Class=KRCC>
처음부터 일반화시키면 어렵잖아. 그래서 익숙해져야 한다고. 그래서 n이 5일 때도 해보고 아까처럼 n이 6일 때, n이 7일 때, n이 8일 때 조금 해보면 짝수일 때와 홀수일 때와 분위기가 다르구나. 일반화시켜볼까. 

<SYNC Start=3352132><P Class=KRCC>
왜? 어차피 칸막이 이용해서 이웃하지 않도록 하는 경우인데 이웃하지 않도록 할 대상이 2가지가 있으니까 조금 짜증 났거든. 그래도 다시 한번 생각해보라고요. 

<SYNC Start=3360525><P Class=KRCC>
이 정도의 느낌까지 해보는데, 나중에 원순열이 나오는데 원순열 중에서 이렇게 이웃하지 않도록 하는 것은 이것 한 문제만 어느 정도 되면 어떤 어려운 문제가 나오더라도 충분히 해결할 수 있을 테니까 

<SYNC Start=3373538><P Class=KRCC>
그런 느낌으로 레벨 3을 같이 공부하셨으면 좋겠어요. 좋은 소식 있어요. 2번과 3번은 이것만큼 괴롭지 않습니다. 그리고 필수 과정입니다. 다음 시간에 이어서 가도록 하겠습니다. 
<SYNC Start=3387138><P Class=KRCC>&nbsp;

</BODY>
</SAMI>
