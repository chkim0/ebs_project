<SAMI>
<HEAD>
<TITLE>Time Tools (C) CCNSOFT 2005</TITLE>
<STYLE TYPE="text/css">
<!--
P { margin-left:8pt; margin-right:8pt; margin-bottom:2pt;
    margin-top:2pt; font-size:12pt; text-align:left;
    font-family:굴림, Arial; font-weight:normal; color:white;
    background-color:#405A8D; }
.KRCC { Name:한국어; lang:ko-KR; SAMIType:CC; }
#STDPrn { Name:Standard Print; }
#LargePrn { Name:Large Print; font-size:20pt; }
#SmallPrn { Name:Small Print; font-size:10pt; }
-->
</STYLE>
</HEAD>
<BODY>
<SYNC Start=9645><P Class=KRCC>
반갑습니다. 2022 최은진의 수능 특강 확률과 통계 강의에 오셨습니다. 저는 여러분의 든든한 조력한, 체인지 수학 최은진입니다.
<SYNC Start=18751><P Class=KRCC>
오늘이 이제 네 번째 시간이 되겠고요, 오늘 여러분과 제가 함께 공유하게 될 감성 코드는 기쁨. 왜 갑자기 기쁨이냐 하면 오늘 하게 되는 같은 것이 있는 순열,
<SYNC Start=36432><P Class=KRCC>
제목에서 확인하실 수 있잖아요. 같은 것이 있는 순열은 사실 그래요. 제가 느끼기에는 여러 가지 순열 중에서는 제일 무난하게 느끼는 부분이에요.
<SYNC Start=48136><P Class=KRCC>
좀 수월하다고 느끼는 부분인데다가, 맨 뒤에 최단거리 길 찾기가 나오는데 그 부분조차도 처음에 보기에는 '어려운가?'라고 생각할 수 있지만
<SYNC Start=58458><P Class=KRCC>
막상 공부하다 보면 수작업으로 우리 어렸을 때 했던, 초등학교 때 했던 그런 아이디어로 풀릴 수 있는 문제가 대부분이라서
<SYNC Start=67848><P Class=KRCC>
오히려 여러분이 좀 기분 좋게 공부할 수 있는 부분이 아닐까 싶어서 너무 부담감을 갖지 말로 좀 내려놓으라는 생각으로 기쁨이라고 제가 감성 코드를 정해 봤거든요.
<SYNC Start=77952><P Class=KRCC>
기분 좋게 공부 시작해 보자고요. 지금부터 오늘의 목표 화면으로 확인하면서 가도록 할게요. 오늘은 개념으로 같은 것이 있는 순열 첫 번째 두 번째 이렇게 나눠서 볼 것이고요,
<SYNC Start=91057><P Class=KRCC>
그중에서도 최단거리 길 찾기 같이 보도록 하겠습니다. 오늘의 코드입니다. 코드 열네 번째는 같순, 같은 것이 있는 순열의 원리,
<SYNC Start=98857><P Class=KRCC>
그다음에 열다섯 번째 코드는 순서가 정해져 있다면 같순을 떠올려라, 그다음에 열여섯 번째 코드는…. 아, 아니다. 여섯 번째 코드, 강조 코드 하나 넣었고요.
<SYNC Start=108134><P Class=KRCC>
특별한 조건이 있는 순열. 그다음에 세 번째 코드, 추가로 나열의 의미를 반영해서 다시 한번 코드 강조하고요. 열여섯 번째 코드까지 갈게요.
<SYNC Start=117150><P Class=KRCC>
같순을 이용한 최단거리 길 찾기, 장애물이 있는 경우까지 해서 오늘은 이렇게 살펴보도록 하겠습니다. 여러분 제가 강조 혹은 추가라고 올려 드리는 그 코드들은
<SYNC Start=126258><P Class=KRCC>
예전에 나왔던 코드인데 거기에다가 무언가를 추가했다거나 예전에 나왔던 코드인데 이번 문제 풀이에 다시 한번 활용된다거나
<SYNC Start=134020><P Class=KRCC>
그럴 때 강조 혹은 추가라는 코드로 여러분에게 제공하는 것이니까 그렇게 알고 다시 한번 떠올리면서 여러분의 말로 글로 정리해 보시면 되겠습니다.
<SYNC Start=145572><P Class=KRCC>
그러면 지금부터 시작해 보도록 할 것이고요. 오늘 이 같은 것이 있는 순열은 이것도 역시 예제를 보면서 보시는 게 맞아요.
<SYNC Start=156403><P Class=KRCC>
도입은 예제와 함께하시는 게 여러분 이해가 가장 쉽고 그걸 공식화하기에 수월하거든요. 그래서 이 기출 문제를 보면서 제가 같은 것이 있는 순열을 공식화해 드릴게요.
<SYNC Start=169214><P Class=KRCC>
다른 순열에 비해서 얘는 공식으로 만들었을 때 공식의 활용도가 굉장히 높고요, 공식이 어렵지 않고요, 그러나 공식을 이해하는 과정은 반드시 필요하고요.
<SYNC Start=179926><P Class=KRCC>
그래서 이 기출을 가지고 한번 얘기해 볼게요. 따끈따끈한 20년에 나왔던 6월 기출이었습니다. '6개의 문자를 가지고 일렬로 나열하는 경우의 수를 구하시오.'라고 했습니다.
<SYNC Start=190200><P Class=KRCC>
사실 우리 조금 했다 하는 친구들은 이거 보지도 않고 어떻게 할 거냐 하면 '6개이니까 일단 나열하고, a가 똑같은 게 3개 있고 b가 2개 있으니까 3!이랑 2!로 나눠서 계산하면 돼.'라고 할 걸요.
<SYNC Start=204729><P Class=KRCC>
'어, 저게 뭐야?' 하는 친구들도 괜찮아요. 있어도 돼요. 이게 왜 나오는지를 제가 지금 해 드리려고 하는 것이거든요. 이게 같은 것이 있는 순열의 공식이에요.
<SYNC Start=213646><P Class=KRCC>
문자 6개를 나열하는데 이 안에서 같은 문자가 속해 있는 거예요. a 똑같은 문자가 3개 속해 있고 똑같은 문자 b가 2개 속해 있는 이런 경우를 얘기하는 거죠.
<SYNC Start=224856><P Class=KRCC>
그렇다면 '얘를 도대체 왜 6개의 문자를 다 나열한 다음에 같은 것끼리 자리 바꾸는, 같은 것끼리 자리 바꾸는 것들로 곱해서 나눠 줄까? 왜 그럴까?'를 지금부터 볼 건데요.
<SYNC Start=239522><P Class=KRCC>
이렇게 갈게요. 예를 들어 이걸 나열한다고 하면 이런 순서 괜찮고요, 아니면 이런 순서도 있고요, 뭐 이제 이런 것들 다 세기 시작해야겠죠. 맞아요?
<SYNC Start=263404><P Class=KRCC>
이런 걸 어떻게 세냐는 거죠. 그래서 어떻게 할 생각이냐 하면 일단 같은 문자를 같다고 생각하지 말고 구분을 합시다. 번호를 붙이려고요. 얘도 이렇게.
<SYNC Start=281991><P Class=KRCC>
그러면 이렇게 세고 싶은 건 사실은 만약에 같은 문자끼리 구분해 버리면 어떻게 되는 거냐 하면 이렇게 a1, a2, a3가 자리를 바꿀 수 있죠. a1, a3, a2.
<SYNC Start=297668><P Class=KRCC>
a2로 시작해서 a1, a3도 될 수 있고 a2로 시작해서 a3, a1도 될 수 있죠. 그다음에 a3로 시작해서 a1, a2도 될 수 있고 a3로 시작해서 a2, a1도 될 수 있죠.
<SYNC Start=311684><P Class=KRCC>
이렇게 자리 바꾸는 게 총 몇 가지예요? 여섯 가지죠. 사실은 이 여섯 가지 우리 계산도 가능해요. a1, a2, a3가 서로 자리 바꾸는 방법의 수이니까 3!인 거죠.
<SYNC Start=323431><P Class=KRCC>
그렇지만 그걸 다 a, a, a, 같은 문자로 보고 1개로 세고 싶다는 거예요. 무슨 말인지 아세요? 얘네끼리 자리 바꾸는 것을.
<SYNC Start=333641><P Class=KRCC>
또한 b도 그때마다 b1, b2 아니면 b2, b1으로 쓸 수 있겠죠. 그걸 b, b로 문자 구분을 안 하면 똑같이 하나로 세겠다는 거니까.
<SYNC Start=346273><P Class=KRCC>
이것도 이때마다 b1, b2 그리고 b2, b1 이렇게 갈 수 있다는 거죠. 쉽게 말하면 b 입장에서도 두 가지 케이스가 나오는 거예요, 자리 바꾸는 방법이.
<SYNC Start=358963><P Class=KRCC>
c야 어차피 똑같이 하나이고. 그러니까 b가 b끼리 자리 바꾸는 방법이 2!이죠. 그러면 a끼리 자리 바꾸고 b끼리 그때마다 동시에 자리 바꾸는 방법은 3! 곱하기 2!을 해야 되잖아.
<SYNC Start=375453><P Class=KRCC>
그래야 a끼리 a1, a2, a3가 자리 바꾸면서 그때마다 b도 같이 자리 바꿔서 총 12개가 나오는 거예요. 3 곱하기 2는 6, 곱하기 2 하니까 12. 이해되세요?
<SYNC Start=386370><P Class=KRCC>
그런데 이렇게 자리 바꾸는, c는 마지막에 오고, 이런 열두 가지 경우를 다 묶어서 뭐로 세겠다는 거예요? aaabbc라는 1개로 세겠다는 거예요.
<SYNC Start=401854><P Class=KRCC>
무슨 말인지 아시겠죠? 이 같은 문자라고 생각한다면. 얘네를 다 다른 문자로 구분했다면 12개가 나올 수 있는 건데 그걸 묶어서 하나로 세겠다는 얘기인 거죠.
<SYNC Start=416500><P Class=KRCC>
이해되세요? 그러면 또 볼까요? 이때는요? 이때도 마찬가지죠. aabbac이다. 그러면 이때도 a1, a2, b1, b2, 그다음에 a3, c 이렇게 배열이 된 것일 수도 있고,
<SYNC Start=431671><P Class=KRCC>
아니면 여기가 자리가 바뀌어서 a2…. 아, 쏘리. a1을 먼저 할게. a1, 그다음에 여기가 a3이고 여기가 a2가 되고요. 그다음에 a2, a1, a3. a2에 a3, a1.
<SYNC Start=451092><P Class=KRCC>
아니면 이번에는 a3에다가 a1, a2가 될 수도 있고요, 이번에는 a3에다가 a2, a1이 될 수도 있고. 무슨 말인지 알죠? a끼리 자리 바꾸는 게 또 여섯 가지인 거예요, 3!.
<SYNC Start=462335><P Class=KRCC>
그리고 b가 b2, b1 자리 바꾸니까 그때마다 또 2개 자리 바꾸는 거죠. 그러니까 이때도 12개예요. 그러니까 말하자면 aabbac라고 이렇게 세고 싶은 나열 순서를
<SYNC Start=477716><P Class=KRCC>
문자 자체를 같은 문자를 구분해 버리면 열두 가지가 나왔던 거예요, 사실은. 그런데 그것을 1개라고 세고 싶은 거죠.
<SYNC Start=487808><P Class=KRCC>
어디에서 많이 봤거든요. 뭐냐 하면 나눗셈에 대한 확률적 사고예요. 일단 세요, 6!로. 그런 다음에 12개를 하나로 세고 싶으니까 12로 나눠 주면 돼요.
<SYNC Start=500442><P Class=KRCC>
그러면 이런 게 몇 세트가 나오는지, 그게 결국 경우의 수가 나오는 거죠. 그런데 이렇게 12라고 하기가 좀 그렇죠.
<SYNC Start=509104><P Class=KRCC>
식을 갖고 와서 해야 되니까 3! 곱하기 2! 이렇게 가시면 되는 거죠. 그래서 이거 계산해 주시면 이렇게 하니까 60이 되나요? 이렇게 해서 정리해 주시면 되는 문제입니다.
<SYNC Start=525952><P Class=KRCC>
하실 수 있겠어요? 사실 답을 구하는 건 진짜 어렵지 않고요, 이거 4번에 나왔다는 건 첫 페이지에 나왔다는 것이거든요. 굉장히 쉬운 문제로 출제한 건데요.
<SYNC Start=535633><P Class=KRCC>
같은 것이 있는 순열은 공식을 사용했을 때 워낙 시간을 세이브 하고 훨씬 더 수월하게 갈 수 있기 때문에 공식을 너무나 많이 활용해요.
<SYNC Start=544273><P Class=KRCC>
그래서 같은 것이 있는 순열은 그 어떤 문제보다도 공식의 활용도가 높고 공식을 썼을 때 유리합니다. 공식을 이해하는 게 어렵지만은 않을 것 같아요.
<SYNC Start=555182><P Class=KRCC>
그래서 제가 써 드린 내용들을 왜 도대체 일단 나열을 하고 아까 6! 하고 3!2!으로 나누는지, 뭐로 나눈 거예요? 같은 것으로 취급하고 싶은 것의 개수.
<SYNC Start=571985><P Class=KRCC>
원순열에서 일단 나열을 하고 '돌같개', 돌렸을 때 같은 것의 개수로 나눴던 것 있죠? 그것이랑 똑같아요. 일단 나열을 하고 같은 것으로 취급하고 싶은 것의 개수를 나눠 줘서
<SYNC Start=584401><P Class=KRCC>
전체적으로 세트가 몇 세트 나오는지를 완성하는 전형적인 확률적 사고의 나눗셈 방법인 거예요. 그래서 같은 것이 있는 순열은 서로 다른 n개를 나열하는 거죠.
<SYNC Start=603337><P Class=KRCC>
n개를 나열하는데, 대신에 이때 p개, q개, r개가 같은 것이 섞여 있다. 그렇다면 어떻게 나열하느냐. n! 일단 하고, 일단 나열하고 같은 것들끼리,
<SYNC Start=624306><P Class=KRCC>
서로 분리해 놨다고 가정했을 때 그들끼리 자리 바꾸는 것. 그런데 얘네끼리 자리 바꾸고 얘네끼리 자리 바꾸고 그때마다 벌어지니까 그것들을 서로 곱해야겠죠.
<SYNC Start=633851><P Class=KRCC>
그렇게 해서 그것으로 나눠 주면 총 세트의 개수가 나오니까 같은 것이 있는 순열로 계산할 수 있겠더라. 이렇게 되는 게 바로 같은 것이 있는 순열의 공식입니다.
<SYNC Start=644859><P Class=KRCC>
그 어떤 공식보다 수월하고요, 그 어떤 공식보다 활용도가 높습니다. 그래서 여러분 그렇게 생각하시고 기억해 주시면 되겠고요.
<SYNC Start=654327><P Class=KRCC>
그래서 이런 문제를 풀 때는 6!을 3!2! 이렇게 나누는 방법을 쓰시면 되고요. 일단 나열한다. 그리고 같은 것으로 취급하고 싶은 것의 개수로 나눠 준다.
<SYNC Start=668644><P Class=KRCC>
그런데 이 문제는 이렇게 푸신 분도 있을 수 있어요. '선생님, 일렬로 나열할 때 a끼리 구분은 안 되니까 a가 들어갈 자리 3개 저 선택할래요. 그래서 거기에 a 넣을래요.
<SYNC Start=687894><P Class=KRCC>
그리고 b가 들어갈 자리 2개 선택할래요. 그중에 b 넣을래요. 나머지 하나에 c 채울게요. 이렇게 하면요?' 괜찮아요. 계산해 보시면 똑같아요.
<SYNC Start=714826><P Class=KRCC>
그래서 같은 것이 있는 순열은, 앞으로 제가 같순이라고 많이 부를 것이거든요. 조합과 아이디어가 같아요. 이해되시죠?
<SYNC Start=730669><P Class=KRCC>
그래서 같은 것이 있는 순열에서 기억하셔야 될 것은 두 가지입니다. 일단 나열을 하고 같은 것으로 취급하고 싶은,
<SYNC Start=740318><P Class=KRCC>
그러니까 같은 것을 구분했다고 생각했을 때 그들끼리 자리 바꾸는 것 있죠? 그것들의 개수로 나눠 주게 되어서 결국에는 전체적으로 세트의 수를 세어 준다, 그걸 기억하시고요.
<SYNC Start=751918><P Class=KRCC>
또 하나는 같은 것이 있는 순열은 결국 그 자리를 정해 주는, 들어갈 자리를 정해 주는 조합과 완전히 원리가 같다. 답도 같고 식도 같고. 그렇게 기억하시면 되고요.
<SYNC Start=766045><P Class=KRCC>
따라서 코드 열네 번째로 연결하고 문제 풀이 본격적으로 해 볼게요. 같순의 원리입니다. 나열 후 취소라는 것은 확률적 사고에서 나눗셈의 의미입니다.
<SYNC Start=775162><P Class=KRCC>
제가 1강에서 해 드렸고요. 같은 것으로 취급하고 싶은 것들을 묶어서 하나로 생각하고 센다는 의미를 가지고 있습니다.
<SYNC Start=781689><P Class=KRCC>
두 번째는 같순은 조합과 원리와 답이 완전히 같기 때문에 같이 생각해 주시면 좋겠습니다. 여기에서 열다섯 번째 코드까지 연결해서 바로 가서 문제 풀이를 해 볼게요.
<SYNC Start=794978><P Class=KRCC>
순서가 정해져 있다. 그렇다면 같순을 떠올려라. 이 말도 정말 많이 씁니다. 어떤 문제에서 꼭 a, a, a라고 같은 문자로 주면 당연히 같은 것이 있는 순열로 나열해야겠지만,
<SYNC Start=807014><P Class=KRCC>
같은 것이 있는 순열이라고 딱 같은 것이라고 주는 게 아니라 그냥 순서를 정해 주는 경우가 있어요. 그런 경우는 자리 바꾸지 않는다는 거잖아요, 결국 순서가 정해져 있다는 건.
<SYNC Start=819681><P Class=KRCC>
그래서 순서가 정해져 있다면 그런 건 같은 것으로 여겨서 같은 것이 있는 순열을 이용해도 된다는 게 열다섯 번째 코드입니다.
<SYNC Start=827142><P Class=KRCC>
그래서 이것까지도 같이 보면서 다음 문제 풀어 보도록 할게요. 열다섯 번째 코드도 기억해 두세요. 연계 교재 레벨 1의 6번 문제입니다.
<SYNC Start=836801><P Class=KRCC>
6개의 문자를…. 아, 이거 7개의 문자 아닌가요? 그렇죠? a, a, a, b, b, c, d이네요. 그렇죠? 7개의 문자를 모두 일렬로 나열할 때, 2개의 문자 b가 모두 문자….
<SYNC Start=849754><P Class=KRCC>
아, 6개가 맞고요, a가 하나 없네요. 그렇죠? 이렇게 되어 있는 문제입니다. 다시 볼게요. 2개의 문자 b가 모두 문자 d보다 오른쪽에 있는 경우를 구하래요.
<SYNC Start=860749><P Class=KRCC>
그러면 이제 이 얘기죠. 문자 b가 d보다 항상 오른쪽에 있다는 건 b, b 얘네는 전부 다 d보다 오른쪽에 배열해야 되는 거예요. 그러면 d가 이것보다 오른쪽에는 못 가죠.
<SYNC Start=875248><P Class=KRCC>
b보다 오른쪽에 못 간다는 얘기죠. 그리고 사이사이에는 누가 와도 상관없어요. a가 여기에 다 오고 c 이렇게 와도 되고요, 아니면 a는 뭐 이런 데 사이에 끼어도 되고요,
<SYNC Start=885181><P Class=KRCC>
뭐 그런 건 중요하지 않아요. 이 사이에 끼어도 돼요, 사실. d랑 b의 순서만 정해져 있는 거예요, 사실은. 이럴 때도 같은 것이 있는 순열을 이용한다는 거죠.
<SYNC Start=896726><P Class=KRCC>
순서가 정해져 있잖아요. 그래서 d랑 b랑 b는 나온다면 무조건 이 순서예요. 원래는 이렇게 놓을 수 있고 원래는 이렇게 놓을 수 있잖아.
<SYNC Start=911897><P Class=KRCC>
d가 여기에 오거나 여기에 오거나 여기에 오거나 3개 올 수 있잖아. 그런데 b보다는 무조건 왼쪽에 이렇게 와야 되는 거잖아요, b가 d보다 오른쪽에 온다는 얘기는.
<SYNC Start=920780><P Class=KRCC>
그러니까 얘 안 되고 얘 안 된다는 거니까 이것만 되는 거죠. 그러니까 b랑 d가 오면 순서가 없이 1개의 순서만 생각한다는 거니까 이것을 차라리 b, b, b로 간주하면 된다는 거죠.
<SYNC Start=933796><P Class=KRCC>
그러면 순서 바꾸지 않아도 되니까. 그래서 d 대신에 b로 생각하자. 이해되시죠? 그래서 이 문제는 어떻게 나열하는 거냐 하면 a, a, b, b, c, b 이걸 나열하는 거죠.
<SYNC Start=955134><P Class=KRCC>
그러면 결국 뭐예요? 6개를 나열하고 같은 것이 있는 2개로 나누고, 2!, 같은 것 3개끼리 자리 바꾸는 걸로 나누게 되는 거죠. 이해되시나요?
<SYNC Start=966383><P Class=KRCC>
그래서 6!을 2!3!로 나누면 아까 처음에 했던 정답 60이네요. 이런 식으로 다시 한번 코드 확인할게요. 열다섯 번째 코드였습니다.
<SYNC Start=976644><P Class=KRCC>
순서가 정해져 있었다면 같은 것이 있는 순열을 써도 좋다. 꼭 같은 문자로 제시되지 않았지만 '뭐는 뭐보다 왼쪽에 있다. 뭐는 뭐보다 오른쪽에 있다.' 뭐 이런 식으로 정해져 있다면
<SYNC Start=989541><P Class=KRCC>
같은 것으로 아예 박아 놓고 같은 것이 있는 순열로 세어도 좋다, 이렇게 생각하시면 되겠습니다. 그렇다면 이제 또 다음 코드로 넘어가서 그다음 문제 풀이 한번 해 볼게요.
<SYNC Start=1001448><P Class=KRCC>
이것은 우리 예전에 했던 코드 강조 코드입니다. 특별한 조건이 있는 순열이에요. 다시 한번 보지 말고 연습해 보자.
<SYNC Start=1007787><P Class=KRCC>
만약에 몇 명의 자리가 고정되어 있다. 그러면 고정된 자리 먼저 배치하고 가면 되고. '이웃하거나 이웃하지 않는다.'가 나오면, '이웃한다.'가 나오면 묶어라.
<SYNC Start=1015845><P Class=KRCC>
그런 다음에 전체를 배열하고 안을 들여다보고 그들끼리 자리 바꾸는 걸 같이 곱해라. 이웃하지 않는다. 그러면 두 명일 경우는 전체에서 이웃하는 걸 빼도 괜찮고,
<SYNC Start=1028090><P Class=KRCC>
뭐 일반적인 경우라면 대부분은 이웃해도 좋은 걸 먼저 배치하고 사이사이에 끼워 넣는다, 이렇게 했고. 마지막으로 남녀가 교대로 선다.
<SYNC Start=1038793><P Class=KRCC>
그렇다면 남자든 여자든 먼저 하나를 배치하고 사이사이에 들어갈 수 있게 다른 성을 배치하면 된다. 이렇게 생각했었죠.
<SYNC Start=1047566><P Class=KRCC>
특별한 조건이 있는 순열 다시 한번 입으로 확인하시고요. 이게 사실은 원순열에서 많이 나왔던 부분인데요, 같은 것이 있는 순열에서도 이런 얘기들을 종종 활용합니다.
<SYNC Start=1058096><P Class=KRCC>
그래서 기억을 같이 하시고요. 세 번째 코드는 나열의 의미였는데요, 여기에다가 이제 하나 더 추가해서 말씀드리려고요. 3명을 일렬로 나열한다. 그러면 3!.
<SYNC Start=1068236><P Class=KRCC>
우리 이미 했었어요. 서로 다른 3개의 자리에 앉히는 방법이니까. 자동 배열한다. 그러면 순서는 정해져 있으니까 그냥 조합입니다.
<SYNC Start=1075811><P Class=KRCC>
3명을 원탁에 나열한다. 그러면 2!이었죠. a, a, b, b, 같은 것이 있게 나열한다. 4!을 2!2!로 나누시면 되죠. 그래서 나열 코드에 같은 것이 있는 순열로 나열하는 코드를 추가해서
<SYNC Start=1091605><P Class=KRCC>
같이 알아 두시면 되겠습니다. 나열을 한다는 것은 아무런 제약 조건이 없으면 그냥 팩토리얼인데, 거기에서 만약에 조합이라면 자동 배열이니까 세지 않고 한 가지이고요. 그렇죠?
<SYNC Start=1101873><P Class=KRCC>
원탁에 배열한다면 하나 빼고 팩토리얼이고요. 같은 것이 있는 순열로 배열한다면 같은 것이 있는 개수로 나눠 주시면 돼요, 팩토리얼 붙여서.
<SYNC Start=1109366><P Class=KRCC>
그래서 이렇게 나열 코드까지 같이 다시 한번 확인해 주시면 되겠습니다. 여기까지 되셨죠? 그렇다면 이 내용을 가지고 우리는 예제 3번을 풀어 보면서 다시 한번 확인하도록 하겠습니다.
<SYNC Start=1122301><P Class=KRCC>
파란 공 4개, 노란 공 2개, 흰 공 1개를 모두 일렬로 나열할 때, 양 끝에는 같은 색의 공이 놓이는 경우의 수를 한번 구해 보라고 했습니다.
<SYNC Start=1131888><P Class=KRCC>
그러면 일단 얘들아, 수작업을 좀 하셔야 돼요. 모든 문제는 '공식을 어떻게 적용하지?'부터 시작하면 땡이에요. 그렇게 푸는 게 아니에요, 확통도.
<SYNC Start=1143552><P Class=KRCC>
'무슨 공식을 적용할까?'부터 시작하면 난도 높은 문제는 접근을 못 하고요. 그게 아니라 모든 문제의 시작은 사실은 수작업이에요, 확통은.
<SYNC Start=1152759><P Class=KRCC>
그러다가 보면 '아, 얘는 확률적 사고에서 덧셈 뺄셈 곱셈 나눗셈 중에 뭘 활용할까?'가 떠오르게 되고요, 그중에서도 공식을 이용해서 조금 더 단순화시켜서,
<SYNC Start=1164223><P Class=KRCC>
혹은 시간을 단축해서 셀 수 있는 방법이 있는지가 떠오르게 돼요. 그래서 가장 기본은 수작업이고 그 안에서 공식을 섞어서 적용하거나 이런 식으로 하게 되는 겁니다.
<SYNC Start=1176468><P Class=KRCC>
일단 파란 공 4개, 노란 공 2개, 흰 공 1개인데, 모두 다 나열한다고 했으니까 이 양 끝에만 제약 조건이 있고 안에는 제약이 없어요.
<SYNC Start=1190701><P Class=KRCC>
그래서 이렇게 7개를 나열하게 되는 것이고요. 대신에 바깥에 같은 공이 와야 되니까 파란색이 올 수도 있고 노란색이 양 끝에 올 수도 있다는,
<SYNC Start=1201228><P Class=KRCC>
특정한 위치가 정해지면 그 특정하게 정해진 위치를 먼저 고정시켜 놓고 생각한다. 기억나시죠? 그래서 방금 했던 특별한 조건이 있는 순열을 떠올리면서 또 같이 보시면
<SYNC Start=1216283><P Class=KRCC>
이렇게 파란색을 고정시켜 놓으시고요. 그런데 어쨌든 같은 색깔의 공은 구별을 안 하니까 파란 공 2개를 여기에다가 배치하는 것은 방법이 들지 않아요.
<SYNC Start=1226473><P Class=KRCC>
그러고 나서는 여기에 뭐가 남냐 하면 파파 2개 남고 노노, 흰 하나 이렇게 남죠, 이때는. 노노가 들어간 건 파파파파흰 이렇게 남네요.
<SYNC Start=1244627><P Class=KRCC>
그러니까 이제 이것끼리 나열하고 또 이것끼리 나열하고 이런 케이스와 저런 케이스가 있으니까 그들끼리 더하고 이렇게 가시면 되죠.
<SYNC Start=1253703><P Class=KRCC>
따라서 이것은 파파 노노 같은 것이 둘 둘 있으니까 이렇게 같순으로 배열하시고, 파파파파흰 하니까 4! 나누고, 그리고 이런 케이스, 이런 케이스를 더해 주시면 되겠죠.
<SYNC Start=1272331><P Class=KRCC>
5, 4 나누고 3, 2. 6 곱하기 5는 30, 5. 35이네요. 그래서 예제 3번은 정답 35 이렇게 정리하시면 되겠습니다. 아니면 이렇게 생각하셔도 돼요.
<SYNC Start=1287540><P Class=KRCC>
'선생님, 저는 이것 5C4로 하고 싶어요.' 괜찮아요. 5개의 자리 중에 파란색이 들어가는 네 자리 선택한 거죠. '선생님, 저 이것은 파란색이 들어가는 자리 2개랑
<SYNC Start=1300387><P Class=KRCC>
남은 것 중에 노란 자리 2개랑 그다음에 한 자리 중에 흰 자리 이렇게 해서 조합으로 할래요.' 그래도 돼요. 왜냐하면 그래도 결과가 똑같거든요. 됐나요?
<SYNC Start=1318152><P Class=KRCC>
그래서 여러분 세는 방법은 같순으로 세든지 이렇게 조합으로 세든지 여러분이 마음대로 세시되, 이게 여러분 생각으로는 두 가지 크로스 체크를 할 수 있는 하나의 스킬이 되는 거죠.
<SYNC Start=1331531><P Class=KRCC>
같순을 연습해 두되, 문제가 나오면 '아, 같순으로 센 건 조합으로 체크가 가능하구나.'라는 걸 알고 있다면 답을 구해 놨을 때 혹시 오류가 없는지를 체크할 수 있어요.
<SYNC Start=1341499><P Class=KRCC>
그래서 같순, 조합 이렇게 같다고 생각하시고 보시면 될 것 같습니다. 그래서 여기까지 해서 같순 하시고요. 여러분, 저만 기쁨이 이번 강의 코드였나요?
<SYNC Start=1354048><P Class=KRCC>
그렇지 않으시죠? 여기까지 그렇게 많이 어렵진 않으시죠? 뒤에 가도 별로 안 어려워요. 걱정 안 하셔도 돼요. 다음 문제 또 보면서, 유제 6번 한번 보도록 할게요.
<SYNC Start=1365441><P Class=KRCC>
7개의 문자를 모두 나열할 때 caadbbb, 이것과 같이 c와 d 사이에 2개의 문자가 있는 경우의 수를 구하래요. 묶어야겠네. 그렇지?
<SYNC Start=1383745><P Class=KRCC>
c, d 빼고 2개의 문자 누가 올지 모르네. 그렇지만 나머지 3개가 오겠네, 7개이니까. 총 몇 개 나열되는 거야? 문자 4개 나열되는 거네.
<SYNC Start=1397170><P Class=KRCC>
이렇게 하고 가시면 되겠네요. 됐어요? 어떻게 나열할까요? 가장 쉽게 접근할 수 있는 건 제가 봤을 때 수작업이에요. 수작업이 나쁘지 않아요, 여러분.
<SYNC Start=1410383><P Class=KRCC>
확통은 최근에 나오는 트렌드도 그래요. 수작업으로 일단 해 보고 거기에서 공식을 좀 적용하거나 해서 조금 스킬을 살려서 계산하는 것이지, 일단 처음은 수작업이에요.
<SYNC Start=1421770><P Class=KRCC>
대부분의 문제가 그런 걸 많이 의도하기 때문에 여러분 일단 딱 대들어서 체계적으로 경우를 빠짐없이 겹치지 않게 나누는 게 가장 중요합니다.
<SYNC Start=1430880><P Class=KRCC>
그래서 c, d 사이에 2개의 문자가 나오는 경우는 일단 첫 번째는 aa가 오는 경우가 있을 수 있고요, bb가 오는 경우가 있을 수 있고요,
<SYNC Start=1440292><P Class=KRCC>
그렇지 않다면 a, b가 섞여 오는 경우가 있을 수 있겠죠. 그렇다면 이때는 남은 문자는 누구냐 하면 b, b, b이네요.
<SYNC Start=1455411><P Class=KRCC>
이때는 남은 문자가 a, a, b. 이때는 남은 문자가 a, b, b. 맞나요? 그러면 이제 나열을 하면 되죠. 정신을 바짝 차리셔야 돼요. 놓칠 수 있어요.
<SYNC Start=1472958><P Class=KRCC>
우선 이웃한다고 생각하면 돼요, 이런 것은. 이웃한다는 말이 있지는 않지만 느낌은 그렇죠. 이웃하는 경우 묶어라. 그리고 전체를 보고 나열해라. 맞죠?
<SYNC Start=1489368><P Class=KRCC>
그 안에서…. 아, 이것부터 할까요? 첫 번째부터 할게요. 전체를 보고 나열해라. 그런데 이건 일단 하나로 묶였잖아요, c, d 해서.
<SYNC Start=1501391><P Class=KRCC>
그런데 전체를 보고 나열하려고 봤더니 이것은 하나이지만 여기가 b, b, b이니까 같은 것이 3개 섞여 있죠. 그래서 같순으로 배열하는 거예요.
<SYNC Start=1513597><P Class=KRCC>
그러고 나서 안을 들여다봐야죠. a 2개는 자리 바꾸기가 어렵죠, 똑같은 거니까. c, d만 자리 바꿀 수 있죠. cd 아니면 dc.
<SYNC Start=1524858><P Class=KRCC>
이것도 셀게. 한 묶음으로 보면 역시 4!을 이번에는 2!로 나누면 되죠. 그리고 이 안에 b는 어차피 고정되어 있고 자리 못 바꾸고 c, d 바꿀 수 있죠.
<SYNC Start=1541063><P Class=KRCC>
그다음 마지막, 이 경우도 c, d 넣고 하나로 묶어 주고. 그러면 마찬가지로 4!을 여기 b, b 있으니까 같은 것이 있는 순열로 하고.
<SYNC Start=1551015><P Class=KRCC>
그러고 나서 이 c, d가 자리 바꿀 수 있고, 그때마다 이때는 a, b가 다르기 때문에 그들도 바꿀 수 있죠. 그래서 2!이 더 들어가요. 그러면 이건 8, 24, 얘는 48.
<SYNC Start=1568333><P Class=KRCC>
더하면 얼마인가요? 80이네요. 그래서 이 문제의 정답은 80, 이렇게 정리해 주시면 되겠습니다. 제가 봤을 때 이게 조금 더 노멀한 풀이이고요.
<SYNC Start=1578191><P Class=KRCC>
또 다른 풀이를 생각하신 분도 있을 수는 있을 거 같은데요, 저는 이게 조금 더 접근하기 쉬운 풀이가 아닌가 싶습니다. 또 다른 풀이는 이렇게 하셔도 될 것 같아요.
<SYNC Start=1586717><P Class=KRCC>
그래서 이걸 제가 별해로 넣어 드릴게요. 이것은 어떨까요? c, d 사이에 2개의 문자가 있고 싶으니까 먼저 c, d를 빼고 나머지 a, a, b, b, b를 먼저 배열해요.
<SYNC Start=1601189><P Class=KRCC>
여기까지는 5!에 2!3!이거든요. 그러고 나서 c, d 사이에 2개의 문자가 들어가야 되니까 c, d가 올 수 있는 위치는 만약에 하나가 여기에 오면 또 하나는 여기에 와야겠죠, c, d가.
<SYNC Start=1617022><P Class=KRCC>
무슨 말인지 아세요? 그때 c, d가 자리 바꾸는 방법도 있으니까 2! 곱해야 되고. 아니면 여기에 오면 여기에 와야겠죠, c, d가. 아니면 여기에 오면 여기에 와야겠죠.
<SYNC Start=1637165><P Class=KRCC>
아니면 여기에 오고 여기에 올 수도 있죠. 총 몇 가지 나왔어요? 네 가지죠. 네 가지 케이스가 생겨요, c, d의 자리가. 그리고 그때마다 c, d가 서로 자리 바꿀 수 있죠.
<SYNC Start=1654442><P Class=KRCC>
이렇게 세어도 되긴 돼요. 그러면 똑같죠. 사실은 간단해 보이긴 합니다. 그러나 이건 별해로 넣은 이유는 처음부터 이렇게 생각하기 쉽지는 않아요.
<SYNC Start=1669145><P Class=KRCC>
그래서 저라면 제가 드린 첫 번째 풀이가 시간은 조금 더 오래 걸려도 여러분이 조금 더 접근하기 쉬운 풀이라서 좋은 풀이라고 생각은 드네요.
<SYNC Start=1677431><P Class=KRCC>
2개 다 연습해 주시면 좋고요. 다음 기출로 갈게요. '6개의 문자 a, a, b, b, c, c를 나열할 때, a끼리는 이웃하지 않도록'.
<SYNC Start=1687661><P Class=KRCC>
원순열에서만 '이웃한다, 이웃하지 않는다.'를 붙였는데 이렇게 학평에서는 같순에다가도 붙여서 내 본 거죠. 그리고 이때까지는 아직 전 범위가 아니기 때문에 좀 여유가 있었을 것이고.
<SYNC Start=1696961><P Class=KRCC>
그래서 이렇게 한번 출제해 봤다는 것인데. a끼리 이웃하지 않도록 한다고 했으니까 이웃해도 좋은 걸 먼저 배치해라. 그러면 a 빼고 나머지를 먼저 배치하는 거죠.
<SYNC Start=1707417><P Class=KRCC>
그러면 4!, 2!2!. 됐나요? 아니면 4C2 해도 돼요. b 들어갈 자리 2개 뽑고 해도 되죠. 어찌 됐든. 그러고 나서 이제 a가 이웃하지 않아야 되니까 여기, 여기, 여기, 여기, 여기.
<SYNC Start=1724793><P Class=KRCC>
총 몇 개인가요? 5개 중에 두 군데 들어갈 수 있잖아요. 그때마다 5개 중에 두 군데. a끼리는 자리 못 바꾸니까 C로 뽑는 게 맞죠, P 말고. 하실 수 있겠죠?
<SYNC Start=1740039><P Class=KRCC>
60인가요? 정답은 60. 이렇게 정리해 주시면 되는 어렵지 않은 문제였습니다. 이렇게 가볍게 확인했고요. 같은 것이 있는 순열 진짜 안 어렵죠?
<SYNC Start=1751065><P Class=KRCC>
저는 느끼기에 오히려 중복 순열이나 원순열보다 조금 더 쉽게 느낄 수도 있지 않을까 싶어요. 그래서 이제 다음 주제로 넘어가 보도록 할게요.
<SYNC Start=1760924><P Class=KRCC>
같은 것이 있는 순열 두 번째입니다. 최단거리 길 찾기에 우리 응용을 한번 해 보려고요. 한번 보도록 할게요. 제가 그림만 하나 넣어 놨는데 사실 하고 싶은 얘기는 뭐였냐 하면
<SYNC Start=1775262><P Class=KRCC>
'A에서 B까지 가는 최단거리 경로의 수를 구하여라.' 이게 문제거든요. 갔던 길을 다시 가지는 않는다, 이런 조건은 최단거리이기 때문에 당연히 있을 수밖에 없죠.
<SYNC Start=1797881><P Class=KRCC>
이거 보통 어떻게 생각하냐 하면 이렇게 가는 길 있죠? 이게 지금 가로가 다 같은 간격이라고 생각했을 때 a라고 다 해 볼게요. b라고 할까요?
<SYNC Start=1822463><P Class=KRCC>
그러면 결국은 내가 A라는 지점에서 B 지점까지 가려면 왔다 갔다 왔다 갔다 왔다 갔다 가든 슉슉 가든 슉슉 가든 어찌 됐든 a가 몇 번? 5번.
<SYNC Start=1844065><P Class=KRCC>
b가 몇 번? 4번은 무조건 들어가야, 9칸을 가로든 세로든 움직여야, 합쳐서. 특히 가로는 5칸, 합쳐서, 세로는 4칸을 무조건 움직여야 도달하겠구나, 최단거리로.
<SYNC Start=1860986><P Class=KRCC>
그 계산이 나와요. 그래서 결국 이 9개를 나열하는 경우의 수로 문제가 바뀌어요. 왜냐하면 얘네 순서만 정리해 주면 끝나는 거니까. 이렇게 되는 거죠.
<SYNC Start=1879245><P Class=KRCC>
아니면 9C4 혹은 9C5 하셔도 돼요. 식 자체가 같잖아요. 이거 풀면 이것이니까. 그래서 최단거리 길 찾기는 같순이에요. 이걸 보시면 느낌이 확 오시죠.
<SYNC Start=1896067><P Class=KRCC>
그래서 최단거리 길 찾기는 같순이다, 이렇게 기억하시면 되고. 그런데 제가 이 최단거리 경로를 찾는 방법 첫 번째가 같은 것이 있는 순열을 이용하라는 것을 알려 드렸고,
<SYNC Start=1908741><P Class=KRCC>
두 번째 방법은 사실은 수작업이 통해요. 이게 초등학교 때 배웠던, 그래서 제가 기분 좋은 단원이라고 했던 게, 이 단원이,
<SYNC Start=1919913><P Class=KRCC>
여러분이 알고 있던 그 쉬운 계산을 적용해서 답이 나오는 게 있어요. 무슨 말이냐. A에서 B로 갈 때 하나씩 하나씩 직접 세어 보는 거예요.
<SYNC Start=1930828><P Class=KRCC>
이 포인트들마다 올 수 있는 방법의 가짓수를 계산해서 적어요. 한 가지이니까 결국 이 포인트는 두 가지겠죠. 이 포인트는 여기에서만 올 수 있으니까 한 가지이고요,
<SYNC Start=1947036><P Class=KRCC>
이 포인트는 여기에서 오는 방법과 여기에서 오는 방법이 있으니까 이 둘을 더해서 세 가지죠. 이런 식으로 포인트마다, 점들마다 내가 갈 수 있는 경로의 수를 적어 가는 거예요.
<SYNC Start=1960301><P Class=KRCC>
여기는 이렇게 가니까 3이죠. 여기는 6이죠. 1, 여기는 4죠. 여기는 10이네요. 맞아요? 여기는 1이고요, 이렇게 오는 것 5죠. 이렇게 오는 건 15죠.
<SYNC Start=1978657><P Class=KRCC>
이렇게는 1이고 이렇게 오는 건 4죠. 또 이렇게 오면 10이고 이렇게 오면 20, 이렇게 오면 35. 이렇게 오면 1, 이렇게 오면 5, 이렇게 오면 15, 이렇게 오면 35, 이렇게 오면 70.
<SYNC Start=1998235><P Class=KRCC>
이렇게 오면 1. 여기에서 오거나 여기에서 오니까 이 포인트는 6이죠. 이 포인트는 이렇게 아니면 이렇게 오니까 21이죠.
<SYNC Start=2005037><P Class=KRCC>
이 포인트는 이렇게 아니면 이렇게이니까 56이죠. 이 포인트는 이렇게 오거나 이렇게 오니까 126이죠. 그래서 126가지이다, 이렇게 정리하셔도 돼요.
<SYNC Start=2016566><P Class=KRCC>
우리 아까 계산을 안 해 놨네. 9!을 5!4!로 나누거든요. 그거 126 나오거든요. 수작업으로 해도 126이 나와요. 그래서 같은 것이 있는 순열은 수작업으로 해도 괜찮다.
<SYNC Start=2031529><P Class=KRCC>
웬만한 건 수작업으로 풀려요, 어지간한 것은. 너무 특별하게 조건을 꼬아서 주거나, 장애물을, 혹은 뭐 어디를 거치지 말아야 된다,
<SYNC Start=2040698><P Class=KRCC>
혹은 어디를 거쳐야 된다는 걸 약간 올라갔다 내려갔다 왔다 갔다 주거나 이런 건 좀 그런데 그게 아니라면 웬만하면 수작업으로 거의 다 풀리기 때문에
<SYNC Start=2048753><P Class=KRCC>
같은 것이 있는 순열은 기분 좋게 길 찾기를 하셔도 돼요. 세 번째 방법은 얘가 장애물이 있을 때 이렇게 많이 하는데요,
<SYNC Start=2058079><P Class=KRCC>
사실은 장애물이 있을 때는 수작업으로도 많이 해요. 같이 읽어 볼까요? 길잡이 점을 잡아라. 무슨 말이냐 하면 A에서 B까지는 가는 방법을 쪼개서 구하는 거예요.
<SYNC Start=2077996><P Class=KRCC>
다시. 뭐라고? 쪼개서 구하는 거야, 나눠서. A에서 B까지는 가는 것은 어쨌든 대각선을 거치지 않고는 못 가거든요. 그래서 적당한 대각선을 긋는 거예요.
<SYNC Start=2088704><P Class=KRCC>
예를 들어 뭐 이렇게. 그러면 이 점, 이 점, 이 점, 이 점, 이 점, 이 포인트들을 지나지 않고는 갈 수가 없네요. 그래서 P, Q, R, S, T라고 하고
<SYNC Start=2104815><P Class=KRCC>
이 점들을 지나는 방법들을 나눠서 가는 방법들을 쪼갠 다음에, 겹쳐서 가지는 않겠죠. P를 지나면서 Q도 지날 수는 없어요. 그러면 최단거리가 아니죠.
<SYNC Start=2115707><P Class=KRCC>
갔다 왔다 다시 하니까. 그래서 겹치지 않아요. 그래서 이 다섯 가지를 더해 주면 돼요. 길잡이 점이라는 건 저 포인트가 되는 P부터 T까지의 점인데요,
<SYNC Start=2125572><P Class=KRCC>
길잡이 점을 잡을 때는 반드시 거치는 점, 그리고 서로 겹치지 않게. 반드시 거칠 수밖에 없으면서 서로 이 지점이면서 이 지점을 동시에 지나는 그런 점은 안 되고요,
<SYNC Start=2138187><P Class=KRCC>
그렇지 않은 점들로 해서 잡아 주시면 돼요. 대부분 대각선에 잡혀요. 그래서 A에서 P로 갔다가 B로 가는 방법은 한 가지.
<SYNC Start=2146301><P Class=KRCC>
A에서 Q로 갔다가 B로 가는 방법은 어떻게 되냐 하면 이렇게 먼저 세는 거예요. 그러면 여기 4!을 3!로 나누면 되죠. 같은 것이 있는 순열로 해서.
<SYNC Start=2157071><P Class=KRCC>
거기까지 먼저 데려다 놓고, Q에서 B까지 가게 되면 4개, 1개이니까 5개이거든요. 그걸 4!로 나누면 되죠. 4 곱하기 5는 20. 그래서 20.
<SYNC Start=2171960><P Class=KRCC>
그다음에 R이다. 그러면 4!을 2!2!. 아, 여기에다가 하지 말자. 아래에다가 해야지. 4!을 2!2!. R에서 B이다. 그러면 그때마다 5!을 3!2!. 그렇죠?
<SYNC Start=2189377><P Class=KRCC>
그래서 그걸 계산해서 여기에다가 쓰시고. 됐어요? 그러면 6에다가 10이니까 60인가요? 이런 식으로 계산해서 가는 거예요. 또 볼게요.
<SYNC Start=2200566><P Class=KRCC>
만약에 S를 거친다. 그렇다면 이렇게 가죠. 그리고 S에서 다시 B로 가고. 그 방법 하시면 되죠. 4에다가 S에서 B로 가는 건 5!을 3!2!으로 나누면 되나요? 40이네요.
<SYNC Start=2216188><P Class=KRCC>
마지막으로 T에서 B로 간다. 그러면 T까지 가는 방법이 한 가지예요. 그리고 그때마다 T에서 B로 가는 방법은 이 사각형에서 세면 되죠.
<SYNC Start=2226434><P Class=KRCC>
5!을 4!로 나누면 되니까 5이지. 그래서 5. 맞아요? 그런 다음에 이들을 다 더하시면 되죠. 126이네요. 그래서 이것도 126. 알겠죠?
<SYNC Start=2241599><P Class=KRCC>
그런데 굳이 이렇게나 이렇게 쉽게 구할 수 있는데 이렇게 길잡이 점으로 할 필요는 없어요. 그러면 길잡이 점은 언제 쓰느냐. 중간에 이렇게 웅덩이가 있어요, 만약에.
<SYNC Start=2252095><P Class=KRCC>
그러면 얘는 못 거치는 거죠. 그러면 P, Q, T를 지나면서 갈 수 있잖아요. 그래서 P, Q, T를 지나면서 갈 수 있는 것을 더해서 길을 구한다든지.
<SYNC Start=2263708><P Class=KRCC>
중간에 웅덩이나 장애물이나 뭐가 있을 때, 그럴 때 쓰는 방법이라고 알아 두시면 되겠습니다. 됐나요? 그래서 최단거리 길 찾기 문제를 푸는 방법을 몇 가지 생각해 봤습니다.
<SYNC Start=2279902><P Class=KRCC>
열여섯 번째 코드입니다. 같순, 같은 것이 있는 순열을 이용한 최단거리 길 찾기, 장애물이 있는 경우를 포함해서 얘기를 코드로 정리해 드리겠습니다.
<SYNC Start=2292407><P Class=KRCC>
장애물이 있거나 거치지 말아야 하는 점이 있다. 그렇다면 먼저 길잡이 점을 지금처럼 잡은 다음에 같은 것이 있는 순열을 이용해서 경우를 나눠서 구한 다음에 더하시면 돼요.
<SYNC Start=2302701><P Class=KRCC>
그게 가장 베이스가 되는 방법이고요. 두 번째 방법은 제가 보여 드리지는 않았는데요, 전체에서 장애물을 거치는 걸 빼는 게 쉬울 수도 있어요.
<SYNC Start=2310351><P Class=KRCC>
그건 문제마다 판단하시면 되고요. 마지막으로는 '일일이 센다.'의 법칙 있죠? 그 포인트가 되는 점들마다 몇 개의 방법으로 오는지 그것을 세어서 하는.
<SYNC Start=2319503><P Class=KRCC>
가장 쉬운 방법이 될 수 있는데요. 세 번째 방법까지 해서 문제마다 여러 가지 방법으로 연습해 두시면 좋겠습니다.
<SYNC Start=2327515><P Class=KRCC>
대부분의 문제는 이 '일일이 센다.'로 어지간히 다 풀리기 때문에 수능에서는 출제를 많이 하고 있지는 않는 편이에요.
<SYNC Start=2334724><P Class=KRCC>
왜냐하면 일일이 세어서 풀리기 때문에 계산을 해서 푼 사람들하고 속도 차이가 나게 되면 그런 문제는 좋은 문제가 아니거든요.
<SYNC Start=2341771><P Class=KRCC>
그래서 내는 데 약간 조심성이 있는 문제가 돼요, 같은 것이 있는 순열에서 최단거리 길 찾기는. 그러나 쉬운 유형으로 내게 되면 속도 차이가 별로 안 나니까
<SYNC Start=2351089><P Class=KRCC>
그런 유형은 언제든지 나올 수 있다. 그렇게 생각하시면 좋겠습니다. 우리 교재에 있는 유제 5번을 보면서 오늘 마무리해 보도록 하겠습니다.
<SYNC Start=2363087><P Class=KRCC>
유제 5번은 A에서 B까지 최단거리로 가고 싶은 상황이에요. 그렇다면 어디를 꼭 거쳐야 된다, 뭐 한다, 그런 조건은 없어요.
<SYNC Start=2371929><P Class=KRCC>
그래서 그냥 일일이 세는 게 가장 쉬우니까 그것 한번 해 보려고. 오늘의 감성 코드가 기쁨이잖아. 제가 마지막에 기쁨을 드리고 끝내 드릴게요. 보실래요?
<SYNC Start=2382071><P Class=KRCC>
올라가는 방법 한 가지, 한 가지. 이 포인트로 오는 방법은 두 가지, 이 포인트는 한 가지. 이 포인트는 세 가지네요.
<SYNC Start=2393449><P Class=KRCC>
여기로 가는 것 세 가지, 여기로 가는 것 세 가지. 여기 여섯 가지네요. 여기 세 가지. 여기 아홉 가지네요. 여기 세 가지. 여기 열두 가지네요.
<SYNC Start=2402900><P Class=KRCC>
이렇게 오는 것 여섯 가지, 이렇게 오는 것 열다섯 가지, 여기에 오는 것 드디어 스물일곱 가지. 이렇게 세는 방법이 하나. 하실 수 있겠죠? 어렵지 않아요.
<SYNC Start=2414735><P Class=KRCC>
이렇게 세는 방법이 하나 있을 수 있고요. 이제 조금 더 수학적으로 세 보도록 할게요. 길잡이 점을 좀 잡아 보도록 할게요.
<SYNC Start=2422644><P Class=KRCC>
지금 했던 풀이 좋은 풀이예요. 그거 쓰지 말아야 된다는 거 아니에요. 확통은 수작업이 잘되면 그게 제일 좋아요.
<SYNC Start=2430156><P Class=KRCC>
수작업으로 해서 빼 놓거나 자꾸 실수하거나 그러면 문제이지, 이 경우는 수작업으로 실수할 가능성 별로 없어서 수작업이 되면 수작업으로 푸세요.
<SYNC Start=2439824><P Class=KRCC>
그런데 수작업이 조금 어려운 경우가 있을 수도 있고 수작업보다 오히려 공식이 쉬운 경우도 있을 수 있어서 그걸 풀어 드려 볼게요.
<SYNC Start=2448820><P Class=KRCC>
저는 어떻게 생각해 볼 거냐 하면 길잡이 점을 잡는 걸 연습할 겸 이렇게 풀어 보면 어떨까요? A에서 B로 갈 때 꼭 지날 수밖에 없는 점을 한번 잡아 보려고요.
<SYNC Start=2463300><P Class=KRCC>
그러면 반드시 이 점을 지날 수밖에 없잖아요. 그래서 여기에서 쉬어 간다고 생각하고, 그냥 길잡이 점이라고 하기는 민망하지, 1개이니까. 그래도 이걸 가지고 생각해 볼게요.
<SYNC Start=2475353><P Class=KRCC>
두 번째 방법입니다. 여기를 지나면서 B로 가는 방법을 세어 보자. 그러면 A에서 P를 거쳐서 B로 간다고 생각하면 A에서 P로 가는 방법을 먼저 생각해 볼까?
<SYNC Start=2489193><P Class=KRCC>
A에서 P로 가는 방법은 3!을 2!로 나누면 되겠네. P에서 B로 가는 방법은? P에서 B로 가는 방법은 여기 막으면 되겠네.
<SYNC Start=2505920><P Class=KRCC>
그래서 이렇게 가는 걸 먼저 구해. 그러면 5!을 3!2!로 나누면 되지. 그런데 이 길은 못 가잖아. 1개만 빼면 되지. 여사건을 이용한 거예요. 1개만 빼면 돼.
<SYNC Start=2526480><P Class=KRCC>
이렇게 해서 이때마다 P에서 B로 가는 방법을 구해서 곱해 준 상황인 거죠. 27이네요, 3 곱하기 9는 27. 어렵지 않죠?
<SYNC Start=2538508><P Class=KRCC>
이렇게 세면 일일이 세었을 때 혹시 빠뜨린 게 없을까 하는 불안감을 해소할 수 있어서 크로스 체크가 가능하죠. 그래서 이런 식으로 세는 방법 하나 있을 수 있고요.
<SYNC Start=2549133><P Class=KRCC>
아니면 또 다른 방법으로 이건 좀 돌아가는 방법일 것 같긴 한데요, 이렇게…. 뭐죠? 포인트가 되는 점, 뭐죠? 길잡이 점을 이렇게 잡는 방법도 있을 것 같아요.
<SYNC Start=2563939><P Class=KRCC>
여기 잡지 말고 A에서 P를 거쳐서 가는 방법이 있을 수 있고 Q를 거쳐서 가는 방법이 있을 수 있고. 둘 다 거치지는 않겠죠.
<SYNC Start=2577782><P Class=KRCC>
왜냐하면 갔다가 내려오게 되면 최단거리가 아니니까. 그러면 P 거쳐서 가는 것 먼저 따져 볼까? A에서 먼저 여기로 갔다가 위로 올라가면 되니까 3!을 2!로 나누는 거네.
<SYNC Start=2590072><P Class=KRCC>
그리고 여기 가는 방법 한 가지이고. 여기에 왔다가 여기에 왔다가 가니까. 여기에서 B로 가는 방법은 무조건 이렇게밖에 못 가지. 그러면 한 가지네.
<SYNC Start=2600067><P Class=KRCC>
그러고 나서 여기에서 B로 가는 거니까 3!을 2!으로 나누면 되지. 그다음 A에서 Q로 갔다가 B로 가는 건 A에서 이것까지 일단 와야 돼.
<SYNC Start=2612328><P Class=KRCC>
그러고 나서 이리로 가는 거니까 한 가지지. 3!, 2!을 한 가지에 곱하고. Q에서 B로 가는 건 이 정사각형에서 둘, 둘, 둘, 둘 가는 거니까 4!을 2!2!으로 나누면 되네. 그렇죠?
<SYNC Start=2630685><P Class=KRCC>
그렇게 해서 계산. 3 곱하기 3은 9, 3 곱하기 6은 18. 그렇지? 그래서 더하면 27. 이런 것 이런 것 나눠서 계산한 거니까, 겹치지 않게. 정답은 27이다. 하실 수 있겠죠?
<SYNC Start=2647686><P Class=KRCC>
최단거리 길 찾기 어렵지 않습니다. 그래서 이렇게 연습해 주시면, 아마 여러분 다양한 풀이로 연습해 두시면 나중에 혹시 문제 나왔을 때
<SYNC Start=2656198><P Class=KRCC>
많이 어렵지 않은 문제라도 크로스 체크를 하면서 실수를 줄여 나갈 수 있는 길이 되니까 열심히 연습해 보시기 바랍니다.
<SYNC Start=2663863><P Class=KRCC>
오늘은 여기까지 하려고요. 같은 것이 있는 순열은 역시 기쁨의 단원이었습니다. 저만 그렇게 생각하는 건 아니리라고 생각하고요.
<SYNC Start=2671962><P Class=KRCC>
오늘도 복습 잘하시고, 마지막에 올려 드리는 코드 잘 정리해 보시고 수강 후기 게시판에 여러분의 손으로 입으로 정리해서 올려 주시기 바랍니다.
<SYNC Start=2681111><P Class=KRCC>
그러면 우리 다음 시간에 뵐게요.
<SYNC Start=2683077><P Class=KRCC>
 
</BODY>
</SAMI>
